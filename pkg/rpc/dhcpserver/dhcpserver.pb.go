// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: dhcpserver.proto

package dhcpserver

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type SubnetType int32

const (
	SubnetType_invalid_subnet SubnetType = 0
	SubnetType_auth_subnet    SubnetType = 1
	SubnetType_access_subnet  SubnetType = 2
)

var SubnetType_name = map[int32]string{
	0: "invalid_subnet",
	1: "auth_subnet",
	2: "access_subnet",
}

var SubnetType_value = map[string]int32{
	"invalid_subnet": 0,
	"auth_subnet":    1,
	"access_subnet":  2,
}

func (x SubnetType) String() string {
	return proto.EnumName(SubnetType_name, int32(x))
}

func (SubnetType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{0}
}

type OperationType int32

const (
	OperationType_invalid_type OperationType = 0
	OperationType_add_type     OperationType = 1
	OperationType_delete_type  OperationType = 2
	OperationType_modify_type  OperationType = 3
)

var OperationType_name = map[int32]string{
	0: "invalid_type",
	1: "add_type",
	2: "delete_type",
	3: "modify_type",
}

var OperationType_value = map[string]int32{
	"invalid_type": 0,
	"add_type":     1,
	"delete_type":  2,
	"modify_type":  3,
}

func (x OperationType) String() string {
	return proto.EnumName(OperationType_name, int32(x))
}

func (OperationType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{1}
}

type ListType int32

const (
	ListType_invalid_list ListType = 0
	ListType_black_list   ListType = 1
	ListType_white_list   ListType = 2
)

var ListType_name = map[int32]string{
	0: "invalid_list",
	1: "black_list",
	2: "white_list",
}

var ListType_value = map[string]int32{
	"invalid_list": 0,
	"black_list":   1,
	"white_list":   2,
}

func (x ListType) String() string {
	return proto.EnumName(ListType_name, int32(x))
}

func (ListType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{2}
}

type Status int32

const (
	Status_invalid_status Status = 0
	Status_enable_status  Status = 1
	Status_disable_stauts Status = 2
)

var Status_name = map[int32]string{
	0: "invalid_status",
	1: "enable_status",
	2: "disable_stauts",
}

var Status_value = map[string]int32{
	"invalid_status": 0,
	"enable_status":  1,
	"disable_stauts": 2,
}

func (x Status) String() string {
	return proto.EnumName(Status_name, int32(x))
}

func (Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{3}
}

type ServerType int32

const (
	ServerType_invalid_server ServerType = 0
	ServerType_master_server  ServerType = 1
	ServerType_slave_server   ServerType = 2
)

var ServerType_name = map[int32]string{
	0: "invalid_server",
	1: "master_server",
	2: "slave_server",
}

var ServerType_value = map[string]int32{
	"invalid_server": 0,
	"master_server":  1,
	"slave_server":   2,
}

func (x ServerType) String() string {
	return proto.EnumName(ServerType_name, int32(x))
}

func (ServerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{4}
}

type AuthType int32

const (
	AuthType_invalid_auth   AuthType = 0
	AuthType_perpetual_auth AuthType = 1
	AuthType_temporary_auth AuthType = 2
)

var AuthType_name = map[int32]string{
	0: "invalid_auth",
	1: "perpetual_auth",
	2: "temporary_auth",
}

var AuthType_value = map[string]int32{
	"invalid_auth":   0,
	"perpetual_auth": 1,
	"temporary_auth": 2,
}

func (x AuthType) String() string {
	return proto.EnumName(AuthType_name, int32(x))
}

func (AuthType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{5}
}

type ProtocolType int32

const (
	ProtocolType_invalid_ProtocolType ProtocolType = 0
	ProtocolType_DHCPv4_ProtocolType  ProtocolType = 1
	ProtocolType_DHCPv6_ProtocolType  ProtocolType = 2
)

var ProtocolType_name = map[int32]string{
	0: "invalid_ProtocolType",
	1: "DHCPv4_ProtocolType",
	2: "DHCPv6_ProtocolType",
}

var ProtocolType_value = map[string]int32{
	"invalid_ProtocolType": 0,
	"DHCPv4_ProtocolType":  1,
	"DHCPv6_ProtocolType":  2,
}

func (x ProtocolType) String() string {
	return proto.EnumName(ProtocolType_name, int32(x))
}

func (ProtocolType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{6}
}

//通用请求
type ReqStatus struct {
	Index                uint64   `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReqStatus) Reset()         { *m = ReqStatus{} }
func (m *ReqStatus) String() string { return proto.CompactTextString(m) }
func (*ReqStatus) ProtoMessage()    {}
func (*ReqStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{0}
}
func (m *ReqStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReqStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReqStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReqStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReqStatus.Merge(m, src)
}
func (m *ReqStatus) XXX_Size() int {
	return m.Size()
}
func (m *ReqStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ReqStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ReqStatus proto.InternalMessageInfo

func (m *ReqStatus) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

//子网列表
type SubnetInfos struct {
	OperateType          OperationType `protobuf:"varint,1,opt,name=operate_type,json=operateType,proto3,enum=dhcpserver.OperationType" json:"operate_type,omitempty"`
	Ev                   []*SubnetInfo `protobuf:"bytes,2,rep,name=ev,proto3" json:"ev,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *SubnetInfos) Reset()         { *m = SubnetInfos{} }
func (m *SubnetInfos) String() string { return proto.CompactTextString(m) }
func (*SubnetInfos) ProtoMessage()    {}
func (*SubnetInfos) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{1}
}
func (m *SubnetInfos) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubnetInfos) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubnetInfos.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubnetInfos) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubnetInfos.Merge(m, src)
}
func (m *SubnetInfos) XXX_Size() int {
	return m.Size()
}
func (m *SubnetInfos) XXX_DiscardUnknown() {
	xxx_messageInfo_SubnetInfos.DiscardUnknown(m)
}

var xxx_messageInfo_SubnetInfos proto.InternalMessageInfo

func (m *SubnetInfos) GetOperateType() OperationType {
	if m != nil {
		return m.OperateType
	}
	return OperationType_invalid_type
}

func (m *SubnetInfos) GetEv() []*SubnetInfo {
	if m != nil {
		return m.Ev
	}
	return nil
}

type SubnetInfo struct {
	Index                uint64     `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Name                 string     `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	VlanId               int32      `protobuf:"varint,3,opt,name=vlan_id,json=vlanId,proto3" json:"vlan_id,omitempty"`
	Type                 SubnetType `protobuf:"varint,4,opt,name=type,proto3,enum=dhcpserver.SubnetType" json:"type,omitempty"`
	BwType               ListType   `protobuf:"varint,5,opt,name=bw_type,json=bwType,proto3,enum=dhcpserver.ListType" json:"bw_type,omitempty"`
	SubnetValid          uint32     `protobuf:"varint,6,opt,name=subnet_valid,json=subnetValid,proto3" json:"subnet_valid,omitempty"`
	V4Sub                *V4SubInfo `protobuf:"bytes,7,opt,name=v4_sub,json=v4Sub,proto3" json:"v4_sub,omitempty"`
	V6Sub                *V6SubInfo `protobuf:"bytes,8,opt,name=v6_sub,json=v6Sub,proto3" json:"v6_sub,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *SubnetInfo) Reset()         { *m = SubnetInfo{} }
func (m *SubnetInfo) String() string { return proto.CompactTextString(m) }
func (*SubnetInfo) ProtoMessage()    {}
func (*SubnetInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{2}
}
func (m *SubnetInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubnetInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubnetInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubnetInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubnetInfo.Merge(m, src)
}
func (m *SubnetInfo) XXX_Size() int {
	return m.Size()
}
func (m *SubnetInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SubnetInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SubnetInfo proto.InternalMessageInfo

func (m *SubnetInfo) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *SubnetInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SubnetInfo) GetVlanId() int32 {
	if m != nil {
		return m.VlanId
	}
	return 0
}

func (m *SubnetInfo) GetType() SubnetType {
	if m != nil {
		return m.Type
	}
	return SubnetType_invalid_subnet
}

func (m *SubnetInfo) GetBwType() ListType {
	if m != nil {
		return m.BwType
	}
	return ListType_invalid_list
}

func (m *SubnetInfo) GetSubnetValid() uint32 {
	if m != nil {
		return m.SubnetValid
	}
	return 0
}

func (m *SubnetInfo) GetV4Sub() *V4SubInfo {
	if m != nil {
		return m.V4Sub
	}
	return nil
}

func (m *SubnetInfo) GetV6Sub() *V6SubInfo {
	if m != nil {
		return m.V6Sub
	}
	return nil
}

type NetworkSegmentInfo struct {
	Index                uint64   `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Net                  string   `protobuf:"bytes,2,opt,name=net,proto3" json:"net,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NetworkSegmentInfo) Reset()         { *m = NetworkSegmentInfo{} }
func (m *NetworkSegmentInfo) String() string { return proto.CompactTextString(m) }
func (*NetworkSegmentInfo) ProtoMessage()    {}
func (*NetworkSegmentInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{3}
}
func (m *NetworkSegmentInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkSegmentInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkSegmentInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkSegmentInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkSegmentInfo.Merge(m, src)
}
func (m *NetworkSegmentInfo) XXX_Size() int {
	return m.Size()
}
func (m *NetworkSegmentInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkSegmentInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkSegmentInfo proto.InternalMessageInfo

func (m *NetworkSegmentInfo) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *NetworkSegmentInfo) GetNet() string {
	if m != nil {
		return m.Net
	}
	return ""
}

//v4子网
type V4SubInfo struct {
	NetSegment           []*NetworkSegmentInfo `protobuf:"bytes,1,rep,name=netSegment,proto3" json:"netSegment,omitempty"`
	Pool                 []*PoolInfo           `protobuf:"bytes,7,rep,name=pool,proto3" json:"pool,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *V4SubInfo) Reset()         { *m = V4SubInfo{} }
func (m *V4SubInfo) String() string { return proto.CompactTextString(m) }
func (*V4SubInfo) ProtoMessage()    {}
func (*V4SubInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{4}
}
func (m *V4SubInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *V4SubInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_V4SubInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *V4SubInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_V4SubInfo.Merge(m, src)
}
func (m *V4SubInfo) XXX_Size() int {
	return m.Size()
}
func (m *V4SubInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_V4SubInfo.DiscardUnknown(m)
}

var xxx_messageInfo_V4SubInfo proto.InternalMessageInfo

func (m *V4SubInfo) GetNetSegment() []*NetworkSegmentInfo {
	if m != nil {
		return m.NetSegment
	}
	return nil
}

func (m *V4SubInfo) GetPool() []*PoolInfo {
	if m != nil {
		return m.Pool
	}
	return nil
}

//v6子网
type V6SubInfo struct {
	NetSegment           []*NetworkSegmentInfo `protobuf:"bytes,1,rep,name=netSegment,proto3" json:"netSegment,omitempty"`
	Pool                 []*PoolInfo           `protobuf:"bytes,4,rep,name=pool,proto3" json:"pool,omitempty"`
	PdInfo               *PDPrefixInfo         `protobuf:"bytes,5,opt,name=pd_info,json=pdInfo,proto3" json:"pd_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *V6SubInfo) Reset()         { *m = V6SubInfo{} }
func (m *V6SubInfo) String() string { return proto.CompactTextString(m) }
func (*V6SubInfo) ProtoMessage()    {}
func (*V6SubInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{5}
}
func (m *V6SubInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *V6SubInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_V6SubInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *V6SubInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_V6SubInfo.Merge(m, src)
}
func (m *V6SubInfo) XXX_Size() int {
	return m.Size()
}
func (m *V6SubInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_V6SubInfo.DiscardUnknown(m)
}

var xxx_messageInfo_V6SubInfo proto.InternalMessageInfo

func (m *V6SubInfo) GetNetSegment() []*NetworkSegmentInfo {
	if m != nil {
		return m.NetSegment
	}
	return nil
}

func (m *V6SubInfo) GetPool() []*PoolInfo {
	if m != nil {
		return m.Pool
	}
	return nil
}

func (m *V6SubInfo) GetPdInfo() *PDPrefixInfo {
	if m != nil {
		return m.PdInfo
	}
	return nil
}

//地址池
type PoolInfo struct {
	Index                uint64   `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Beg                  string   `protobuf:"bytes,4,opt,name=beg,proto3" json:"beg,omitempty"`
	End                  string   `protobuf:"bytes,5,opt,name=end,proto3" json:"end,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PoolInfo) Reset()         { *m = PoolInfo{} }
func (m *PoolInfo) String() string { return proto.CompactTextString(m) }
func (*PoolInfo) ProtoMessage()    {}
func (*PoolInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{6}
}
func (m *PoolInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PoolInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PoolInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PoolInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PoolInfo.Merge(m, src)
}
func (m *PoolInfo) XXX_Size() int {
	return m.Size()
}
func (m *PoolInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PoolInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PoolInfo proto.InternalMessageInfo

func (m *PoolInfo) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *PoolInfo) GetBeg() string {
	if m != nil {
		return m.Beg
	}
	return ""
}

func (m *PoolInfo) GetEnd() string {
	if m != nil {
		return m.End
	}
	return ""
}

//PD前缀信息
type PDPrefixInfo struct {
	StartPrefix          string   `protobuf:"bytes,1,opt,name=start_prefix,json=startPrefix,proto3" json:"start_prefix,omitempty"`
	EndPrefix            string   `protobuf:"bytes,2,opt,name=end_prefix,json=endPrefix,proto3" json:"end_prefix,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PDPrefixInfo) Reset()         { *m = PDPrefixInfo{} }
func (m *PDPrefixInfo) String() string { return proto.CompactTextString(m) }
func (*PDPrefixInfo) ProtoMessage()    {}
func (*PDPrefixInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{7}
}
func (m *PDPrefixInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PDPrefixInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PDPrefixInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PDPrefixInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PDPrefixInfo.Merge(m, src)
}
func (m *PDPrefixInfo) XXX_Size() int {
	return m.Size()
}
func (m *PDPrefixInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PDPrefixInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PDPrefixInfo proto.InternalMessageInfo

func (m *PDPrefixInfo) GetStartPrefix() string {
	if m != nil {
		return m.StartPrefix
	}
	return ""
}

func (m *PDPrefixInfo) GetEndPrefix() string {
	if m != nil {
		return m.EndPrefix
	}
	return ""
}

//静态绑定
type IpStaticInfos struct {
	OperateType          OperationType   `protobuf:"varint,1,opt,name=operate_type,json=operateType,proto3,enum=dhcpserver.OperationType" json:"operate_type,omitempty"`
	Ev                   []*IpStaticInfo `protobuf:"bytes,2,rep,name=ev,proto3" json:"ev,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *IpStaticInfos) Reset()         { *m = IpStaticInfos{} }
func (m *IpStaticInfos) String() string { return proto.CompactTextString(m) }
func (*IpStaticInfos) ProtoMessage()    {}
func (*IpStaticInfos) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{8}
}
func (m *IpStaticInfos) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IpStaticInfos) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IpStaticInfos.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IpStaticInfos) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpStaticInfos.Merge(m, src)
}
func (m *IpStaticInfos) XXX_Size() int {
	return m.Size()
}
func (m *IpStaticInfos) XXX_DiscardUnknown() {
	xxx_messageInfo_IpStaticInfos.DiscardUnknown(m)
}

var xxx_messageInfo_IpStaticInfos proto.InternalMessageInfo

func (m *IpStaticInfos) GetOperateType() OperationType {
	if m != nil {
		return m.OperateType
	}
	return OperationType_invalid_type
}

func (m *IpStaticInfos) GetEv() []*IpStaticInfo {
	if m != nil {
		return m.Ev
	}
	return nil
}

type IpStaticInfo struct {
	Index                uint64   `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	SubnetId             uint64   `protobuf:"varint,2,opt,name=subnet_id,json=subnetId,proto3" json:"subnet_id,omitempty"`
	Mac                  string   `protobuf:"bytes,3,opt,name=mac,proto3" json:"mac,omitempty"`
	Duid                 string   `protobuf:"bytes,4,opt,name=duid,proto3" json:"duid,omitempty"`
	V4Ip                 string   `protobuf:"bytes,5,opt,name=v4ip,proto3" json:"v4ip,omitempty"`
	V6Ip                 string   `protobuf:"bytes,6,opt,name=v6ip,proto3" json:"v6ip,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IpStaticInfo) Reset()         { *m = IpStaticInfo{} }
func (m *IpStaticInfo) String() string { return proto.CompactTextString(m) }
func (*IpStaticInfo) ProtoMessage()    {}
func (*IpStaticInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{9}
}
func (m *IpStaticInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IpStaticInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IpStaticInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IpStaticInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpStaticInfo.Merge(m, src)
}
func (m *IpStaticInfo) XXX_Size() int {
	return m.Size()
}
func (m *IpStaticInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_IpStaticInfo.DiscardUnknown(m)
}

var xxx_messageInfo_IpStaticInfo proto.InternalMessageInfo

func (m *IpStaticInfo) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *IpStaticInfo) GetSubnetId() uint64 {
	if m != nil {
		return m.SubnetId
	}
	return 0
}

func (m *IpStaticInfo) GetMac() string {
	if m != nil {
		return m.Mac
	}
	return ""
}

func (m *IpStaticInfo) GetDuid() string {
	if m != nil {
		return m.Duid
	}
	return ""
}

func (m *IpStaticInfo) GetV4Ip() string {
	if m != nil {
		return m.V4Ip
	}
	return ""
}

func (m *IpStaticInfo) GetV6Ip() string {
	if m != nil {
		return m.V6Ip
	}
	return ""
}

//错误码和错误描述
type RespResult struct {
	ResultCode           int32    `protobuf:"varint,1,opt,name=result_code,json=resultCode,proto3" json:"result_code,omitempty"`
	Description          string   `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RespResult) Reset()         { *m = RespResult{} }
func (m *RespResult) String() string { return proto.CompactTextString(m) }
func (*RespResult) ProtoMessage()    {}
func (*RespResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{10}
}
func (m *RespResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RespResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RespResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RespResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RespResult.Merge(m, src)
}
func (m *RespResult) XXX_Size() int {
	return m.Size()
}
func (m *RespResult) XXX_DiscardUnknown() {
	xxx_messageInfo_RespResult.DiscardUnknown(m)
}

var xxx_messageInfo_RespResult proto.InternalMessageInfo

func (m *RespResult) GetResultCode() int32 {
	if m != nil {
		return m.ResultCode
	}
	return 0
}

func (m *RespResult) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

type BlackAndWhiteListInfo struct {
	Index                uint64   `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	ListType             ListType `protobuf:"varint,2,opt,name=list_type,json=listType,proto3,enum=dhcpserver.ListType" json:"list_type,omitempty"`
	MacAddress           string   `protobuf:"bytes,3,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
	UserName             string   `protobuf:"bytes,4,opt,name=user_name,json=userName,proto3" json:"user_name,omitempty"`
	SubnetId             uint64   `protobuf:"varint,5,opt,name=subnet_id,json=subnetId,proto3" json:"subnet_id,omitempty"`
	Notes                string   `protobuf:"bytes,6,opt,name=notes,proto3" json:"notes,omitempty"`
	Status               Status   `protobuf:"varint,7,opt,name=status,proto3,enum=dhcpserver.Status" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlackAndWhiteListInfo) Reset()         { *m = BlackAndWhiteListInfo{} }
func (m *BlackAndWhiteListInfo) String() string { return proto.CompactTextString(m) }
func (*BlackAndWhiteListInfo) ProtoMessage()    {}
func (*BlackAndWhiteListInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{11}
}
func (m *BlackAndWhiteListInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlackAndWhiteListInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlackAndWhiteListInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlackAndWhiteListInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlackAndWhiteListInfo.Merge(m, src)
}
func (m *BlackAndWhiteListInfo) XXX_Size() int {
	return m.Size()
}
func (m *BlackAndWhiteListInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BlackAndWhiteListInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BlackAndWhiteListInfo proto.InternalMessageInfo

func (m *BlackAndWhiteListInfo) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *BlackAndWhiteListInfo) GetListType() ListType {
	if m != nil {
		return m.ListType
	}
	return ListType_invalid_list
}

func (m *BlackAndWhiteListInfo) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

func (m *BlackAndWhiteListInfo) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *BlackAndWhiteListInfo) GetSubnetId() uint64 {
	if m != nil {
		return m.SubnetId
	}
	return 0
}

func (m *BlackAndWhiteListInfo) GetNotes() string {
	if m != nil {
		return m.Notes
	}
	return ""
}

func (m *BlackAndWhiteListInfo) GetStatus() Status {
	if m != nil {
		return m.Status
	}
	return Status_invalid_status
}

type BlackAndWhiteListReq struct {
	OperType             OperationType            `protobuf:"varint,1,opt,name=oper_type,json=operType,proto3,enum=dhcpserver.OperationType" json:"oper_type,omitempty"`
	ListInfo             []*BlackAndWhiteListInfo `protobuf:"bytes,2,rep,name=list_info,json=listInfo,proto3" json:"list_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *BlackAndWhiteListReq) Reset()         { *m = BlackAndWhiteListReq{} }
func (m *BlackAndWhiteListReq) String() string { return proto.CompactTextString(m) }
func (*BlackAndWhiteListReq) ProtoMessage()    {}
func (*BlackAndWhiteListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{12}
}
func (m *BlackAndWhiteListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlackAndWhiteListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlackAndWhiteListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlackAndWhiteListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlackAndWhiteListReq.Merge(m, src)
}
func (m *BlackAndWhiteListReq) XXX_Size() int {
	return m.Size()
}
func (m *BlackAndWhiteListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_BlackAndWhiteListReq.DiscardUnknown(m)
}

var xxx_messageInfo_BlackAndWhiteListReq proto.InternalMessageInfo

func (m *BlackAndWhiteListReq) GetOperType() OperationType {
	if m != nil {
		return m.OperType
	}
	return OperationType_invalid_type
}

func (m *BlackAndWhiteListReq) GetListInfo() []*BlackAndWhiteListInfo {
	if m != nil {
		return m.ListInfo
	}
	return nil
}

//index可以0，list_type必须有效
type GetBWListReq struct {
	Index                uint64   `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	ListType             ListType `protobuf:"varint,2,opt,name=list_type,json=listType,proto3,enum=dhcpserver.ListType" json:"list_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetBWListReq) Reset()         { *m = GetBWListReq{} }
func (m *GetBWListReq) String() string { return proto.CompactTextString(m) }
func (*GetBWListReq) ProtoMessage()    {}
func (*GetBWListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{13}
}
func (m *GetBWListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBWListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBWListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetBWListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBWListReq.Merge(m, src)
}
func (m *GetBWListReq) XXX_Size() int {
	return m.Size()
}
func (m *GetBWListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBWListReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetBWListReq proto.InternalMessageInfo

func (m *GetBWListReq) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *GetBWListReq) GetListType() ListType {
	if m != nil {
		return m.ListType
	}
	return ListType_invalid_list
}

type GetBWListResp struct {
	RespList             []*BlackAndWhiteListInfo `protobuf:"bytes,1,rep,name=resp_list,json=respList,proto3" json:"resp_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *GetBWListResp) Reset()         { *m = GetBWListResp{} }
func (m *GetBWListResp) String() string { return proto.CompactTextString(m) }
func (*GetBWListResp) ProtoMessage()    {}
func (*GetBWListResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{14}
}
func (m *GetBWListResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBWListResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBWListResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetBWListResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBWListResp.Merge(m, src)
}
func (m *GetBWListResp) XXX_Size() int {
	return m.Size()
}
func (m *GetBWListResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBWListResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetBWListResp proto.InternalMessageInfo

func (m *GetBWListResp) GetRespList() []*BlackAndWhiteListInfo {
	if m != nil {
		return m.RespList
	}
	return nil
}

type StatusBWListReq struct {
	Index                uint64   `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	ListType             ListType `protobuf:"varint,2,opt,name=list_type,json=listType,proto3,enum=dhcpserver.ListType" json:"list_type,omitempty"`
	Status               Status   `protobuf:"varint,3,opt,name=status,proto3,enum=dhcpserver.Status" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StatusBWListReq) Reset()         { *m = StatusBWListReq{} }
func (m *StatusBWListReq) String() string { return proto.CompactTextString(m) }
func (*StatusBWListReq) ProtoMessage()    {}
func (*StatusBWListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{15}
}
func (m *StatusBWListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatusBWListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatusBWListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatusBWListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatusBWListReq.Merge(m, src)
}
func (m *StatusBWListReq) XXX_Size() int {
	return m.Size()
}
func (m *StatusBWListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_StatusBWListReq.DiscardUnknown(m)
}

var xxx_messageInfo_StatusBWListReq proto.InternalMessageInfo

func (m *StatusBWListReq) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *StatusBWListReq) GetListType() ListType {
	if m != nil {
		return m.ListType
	}
	return ListType_invalid_list
}

func (m *StatusBWListReq) GetStatus() Status {
	if m != nil {
		return m.Status
	}
	return Status_invalid_status
}

type ServerCfgInfo struct {
	Index                uint64     `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	ServerType           ServerType `protobuf:"varint,2,opt,name=server_type,json=serverType,proto3,enum=dhcpserver.ServerType" json:"server_type,omitempty"`
	LocalAddress         string     `protobuf:"bytes,3,opt,name=local_address,json=localAddress,proto3" json:"local_address,omitempty"`
	LocalPort            uint32     `protobuf:"varint,4,opt,name=local_port,json=localPort,proto3" json:"local_port,omitempty"`
	PeerAddress          string     `protobuf:"bytes,5,opt,name=peer_address,json=peerAddress,proto3" json:"peer_address,omitempty"`
	PeerPort             uint32     `protobuf:"varint,6,opt,name=peer_port,json=peerPort,proto3" json:"peer_port,omitempty"`
	MonitorTime          uint64     `protobuf:"varint,7,opt,name=monitor_time,json=monitorTime,proto3" json:"monitor_time,omitempty"`
	MaxUpdateTimes       uint32     `protobuf:"varint,8,opt,name=max_update_times,json=maxUpdateTimes,proto3" json:"max_update_times,omitempty"`
	MaxLoadBalancingTime uint64     `protobuf:"varint,9,opt,name=max_load_balancing_time,json=maxLoadBalancingTime,proto3" json:"max_load_balancing_time,omitempty"`
	AutoUpdateLeaseTime  uint64     `protobuf:"varint,10,opt,name=auto_update_lease_time,json=autoUpdateLeaseTime,proto3" json:"auto_update_lease_time,omitempty"`
	SeparateDigit        uint32     `protobuf:"varint,11,opt,name=separate_digit,json=separateDigit,proto3" json:"separate_digit,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ServerCfgInfo) Reset()         { *m = ServerCfgInfo{} }
func (m *ServerCfgInfo) String() string { return proto.CompactTextString(m) }
func (*ServerCfgInfo) ProtoMessage()    {}
func (*ServerCfgInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{16}
}
func (m *ServerCfgInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServerCfgInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServerCfgInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServerCfgInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerCfgInfo.Merge(m, src)
}
func (m *ServerCfgInfo) XXX_Size() int {
	return m.Size()
}
func (m *ServerCfgInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerCfgInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ServerCfgInfo proto.InternalMessageInfo

func (m *ServerCfgInfo) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *ServerCfgInfo) GetServerType() ServerType {
	if m != nil {
		return m.ServerType
	}
	return ServerType_invalid_server
}

func (m *ServerCfgInfo) GetLocalAddress() string {
	if m != nil {
		return m.LocalAddress
	}
	return ""
}

func (m *ServerCfgInfo) GetLocalPort() uint32 {
	if m != nil {
		return m.LocalPort
	}
	return 0
}

func (m *ServerCfgInfo) GetPeerAddress() string {
	if m != nil {
		return m.PeerAddress
	}
	return ""
}

func (m *ServerCfgInfo) GetPeerPort() uint32 {
	if m != nil {
		return m.PeerPort
	}
	return 0
}

func (m *ServerCfgInfo) GetMonitorTime() uint64 {
	if m != nil {
		return m.MonitorTime
	}
	return 0
}

func (m *ServerCfgInfo) GetMaxUpdateTimes() uint32 {
	if m != nil {
		return m.MaxUpdateTimes
	}
	return 0
}

func (m *ServerCfgInfo) GetMaxLoadBalancingTime() uint64 {
	if m != nil {
		return m.MaxLoadBalancingTime
	}
	return 0
}

func (m *ServerCfgInfo) GetAutoUpdateLeaseTime() uint64 {
	if m != nil {
		return m.AutoUpdateLeaseTime
	}
	return 0
}

func (m *ServerCfgInfo) GetSeparateDigit() uint32 {
	if m != nil {
		return m.SeparateDigit
	}
	return 0
}

type SetServerCfgReq struct {
	OperType             OperationType    `protobuf:"varint,1,opt,name=oper_type,json=operType,proto3,enum=dhcpserver.OperationType" json:"oper_type,omitempty"`
	ServerConfig         []*ServerCfgInfo `protobuf:"bytes,2,rep,name=server_config,json=serverConfig,proto3" json:"server_config,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *SetServerCfgReq) Reset()         { *m = SetServerCfgReq{} }
func (m *SetServerCfgReq) String() string { return proto.CompactTextString(m) }
func (*SetServerCfgReq) ProtoMessage()    {}
func (*SetServerCfgReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{17}
}
func (m *SetServerCfgReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetServerCfgReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetServerCfgReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetServerCfgReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetServerCfgReq.Merge(m, src)
}
func (m *SetServerCfgReq) XXX_Size() int {
	return m.Size()
}
func (m *SetServerCfgReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SetServerCfgReq.DiscardUnknown(m)
}

var xxx_messageInfo_SetServerCfgReq proto.InternalMessageInfo

func (m *SetServerCfgReq) GetOperType() OperationType {
	if m != nil {
		return m.OperType
	}
	return OperationType_invalid_type
}

func (m *SetServerCfgReq) GetServerConfig() []*ServerCfgInfo {
	if m != nil {
		return m.ServerConfig
	}
	return nil
}

//index可以0，server_type必须有效
type GetServerCfgReq struct {
	Index                uint64     `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	ServerType           ServerType `protobuf:"varint,2,opt,name=server_type,json=serverType,proto3,enum=dhcpserver.ServerType" json:"server_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *GetServerCfgReq) Reset()         { *m = GetServerCfgReq{} }
func (m *GetServerCfgReq) String() string { return proto.CompactTextString(m) }
func (*GetServerCfgReq) ProtoMessage()    {}
func (*GetServerCfgReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{18}
}
func (m *GetServerCfgReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetServerCfgReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetServerCfgReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetServerCfgReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetServerCfgReq.Merge(m, src)
}
func (m *GetServerCfgReq) XXX_Size() int {
	return m.Size()
}
func (m *GetServerCfgReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetServerCfgReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetServerCfgReq proto.InternalMessageInfo

func (m *GetServerCfgReq) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *GetServerCfgReq) GetServerType() ServerType {
	if m != nil {
		return m.ServerType
	}
	return ServerType_invalid_server
}

type GetServerCfgResp struct {
	RespServer           []*ServerCfgInfo `protobuf:"bytes,1,rep,name=resp_server,json=respServer,proto3" json:"resp_server,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *GetServerCfgResp) Reset()         { *m = GetServerCfgResp{} }
func (m *GetServerCfgResp) String() string { return proto.CompactTextString(m) }
func (*GetServerCfgResp) ProtoMessage()    {}
func (*GetServerCfgResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{19}
}
func (m *GetServerCfgResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetServerCfgResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetServerCfgResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetServerCfgResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetServerCfgResp.Merge(m, src)
}
func (m *GetServerCfgResp) XXX_Size() int {
	return m.Size()
}
func (m *GetServerCfgResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetServerCfgResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetServerCfgResp proto.InternalMessageInfo

func (m *GetServerCfgResp) GetRespServer() []*ServerCfgInfo {
	if m != nil {
		return m.RespServer
	}
	return nil
}

type AuthCfgInfo struct {
	Index                uint64   `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Type                 AuthType `protobuf:"varint,2,opt,name=type,proto3,enum=dhcpserver.AuthType" json:"type,omitempty"`
	MacAddress           string   `protobuf:"bytes,3,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
	UserName             string   `protobuf:"bytes,4,opt,name=user_name,json=userName,proto3" json:"user_name,omitempty"`
	ExpireTime           uint32   `protobuf:"varint,5,opt,name=expire_time,json=expireTime,proto3" json:"expire_time,omitempty"`
	ExpireDate           string   `protobuf:"bytes,6,opt,name=expire_date,json=expireDate,proto3" json:"expire_date,omitempty"`
	Notes                string   `protobuf:"bytes,7,opt,name=notes,proto3" json:"notes,omitempty"`
	Status               Status   `protobuf:"varint,8,opt,name=status,proto3,enum=dhcpserver.Status" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AuthCfgInfo) Reset()         { *m = AuthCfgInfo{} }
func (m *AuthCfgInfo) String() string { return proto.CompactTextString(m) }
func (*AuthCfgInfo) ProtoMessage()    {}
func (*AuthCfgInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{20}
}
func (m *AuthCfgInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthCfgInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthCfgInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthCfgInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthCfgInfo.Merge(m, src)
}
func (m *AuthCfgInfo) XXX_Size() int {
	return m.Size()
}
func (m *AuthCfgInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthCfgInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AuthCfgInfo proto.InternalMessageInfo

func (m *AuthCfgInfo) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *AuthCfgInfo) GetType() AuthType {
	if m != nil {
		return m.Type
	}
	return AuthType_invalid_auth
}

func (m *AuthCfgInfo) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

func (m *AuthCfgInfo) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *AuthCfgInfo) GetExpireTime() uint32 {
	if m != nil {
		return m.ExpireTime
	}
	return 0
}

func (m *AuthCfgInfo) GetExpireDate() string {
	if m != nil {
		return m.ExpireDate
	}
	return ""
}

func (m *AuthCfgInfo) GetNotes() string {
	if m != nil {
		return m.Notes
	}
	return ""
}

func (m *AuthCfgInfo) GetStatus() Status {
	if m != nil {
		return m.Status
	}
	return Status_invalid_status
}

type AuthCfgReq struct {
	OperType             OperationType  `protobuf:"varint,1,opt,name=oper_type,json=operType,proto3,enum=dhcpserver.OperationType" json:"oper_type,omitempty"`
	AuthConfig           []*AuthCfgInfo `protobuf:"bytes,2,rep,name=auth_config,json=authConfig,proto3" json:"auth_config,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *AuthCfgReq) Reset()         { *m = AuthCfgReq{} }
func (m *AuthCfgReq) String() string { return proto.CompactTextString(m) }
func (*AuthCfgReq) ProtoMessage()    {}
func (*AuthCfgReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{21}
}
func (m *AuthCfgReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthCfgReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthCfgReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthCfgReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthCfgReq.Merge(m, src)
}
func (m *AuthCfgReq) XXX_Size() int {
	return m.Size()
}
func (m *AuthCfgReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthCfgReq.DiscardUnknown(m)
}

var xxx_messageInfo_AuthCfgReq proto.InternalMessageInfo

func (m *AuthCfgReq) GetOperType() OperationType {
	if m != nil {
		return m.OperType
	}
	return OperationType_invalid_type
}

func (m *AuthCfgReq) GetAuthConfig() []*AuthCfgInfo {
	if m != nil {
		return m.AuthConfig
	}
	return nil
}

type GetAuthCfgReq struct {
	Index                uint64   `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Type                 AuthType `protobuf:"varint,2,opt,name=type,proto3,enum=dhcpserver.AuthType" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetAuthCfgReq) Reset()         { *m = GetAuthCfgReq{} }
func (m *GetAuthCfgReq) String() string { return proto.CompactTextString(m) }
func (*GetAuthCfgReq) ProtoMessage()    {}
func (*GetAuthCfgReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{22}
}
func (m *GetAuthCfgReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAuthCfgReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAuthCfgReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAuthCfgReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAuthCfgReq.Merge(m, src)
}
func (m *GetAuthCfgReq) XXX_Size() int {
	return m.Size()
}
func (m *GetAuthCfgReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAuthCfgReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetAuthCfgReq proto.InternalMessageInfo

func (m *GetAuthCfgReq) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *GetAuthCfgReq) GetType() AuthType {
	if m != nil {
		return m.Type
	}
	return AuthType_invalid_auth
}

type GetAuthCfgResp struct {
	RespAuth             []*AuthCfgInfo `protobuf:"bytes,1,rep,name=resp_auth,json=respAuth,proto3" json:"resp_auth,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *GetAuthCfgResp) Reset()         { *m = GetAuthCfgResp{} }
func (m *GetAuthCfgResp) String() string { return proto.CompactTextString(m) }
func (*GetAuthCfgResp) ProtoMessage()    {}
func (*GetAuthCfgResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{23}
}
func (m *GetAuthCfgResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAuthCfgResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAuthCfgResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAuthCfgResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAuthCfgResp.Merge(m, src)
}
func (m *GetAuthCfgResp) XXX_Size() int {
	return m.Size()
}
func (m *GetAuthCfgResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAuthCfgResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetAuthCfgResp proto.InternalMessageInfo

func (m *GetAuthCfgResp) GetRespAuth() []*AuthCfgInfo {
	if m != nil {
		return m.RespAuth
	}
	return nil
}

type StatusAuthReq struct {
	Index                uint64   `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Type                 AuthType `protobuf:"varint,2,opt,name=type,proto3,enum=dhcpserver.AuthType" json:"type,omitempty"`
	Status               Status   `protobuf:"varint,3,opt,name=status,proto3,enum=dhcpserver.Status" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StatusAuthReq) Reset()         { *m = StatusAuthReq{} }
func (m *StatusAuthReq) String() string { return proto.CompactTextString(m) }
func (*StatusAuthReq) ProtoMessage()    {}
func (*StatusAuthReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{24}
}
func (m *StatusAuthReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatusAuthReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatusAuthReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatusAuthReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatusAuthReq.Merge(m, src)
}
func (m *StatusAuthReq) XXX_Size() int {
	return m.Size()
}
func (m *StatusAuthReq) XXX_DiscardUnknown() {
	xxx_messageInfo_StatusAuthReq.DiscardUnknown(m)
}

var xxx_messageInfo_StatusAuthReq proto.InternalMessageInfo

func (m *StatusAuthReq) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *StatusAuthReq) GetType() AuthType {
	if m != nil {
		return m.Type
	}
	return AuthType_invalid_auth
}

func (m *StatusAuthReq) GetStatus() Status {
	if m != nil {
		return m.Status
	}
	return Status_invalid_status
}

type DisableUserListInfo struct {
	Index                uint64   `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	MacAddress           string   `protobuf:"bytes,2,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
	UserName             string   `protobuf:"bytes,3,opt,name=user_name,json=userName,proto3" json:"user_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DisableUserListInfo) Reset()         { *m = DisableUserListInfo{} }
func (m *DisableUserListInfo) String() string { return proto.CompactTextString(m) }
func (*DisableUserListInfo) ProtoMessage()    {}
func (*DisableUserListInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{25}
}
func (m *DisableUserListInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DisableUserListInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DisableUserListInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DisableUserListInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DisableUserListInfo.Merge(m, src)
}
func (m *DisableUserListInfo) XXX_Size() int {
	return m.Size()
}
func (m *DisableUserListInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DisableUserListInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DisableUserListInfo proto.InternalMessageInfo

func (m *DisableUserListInfo) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *DisableUserListInfo) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

func (m *DisableUserListInfo) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

type DisableUserListReq struct {
	OperType             OperationType          `protobuf:"varint,1,opt,name=oper_type,json=operType,proto3,enum=dhcpserver.OperationType" json:"oper_type,omitempty"`
	CfgInfo              []*DisableUserListInfo `protobuf:"bytes,2,rep,name=cfg_info,json=cfgInfo,proto3" json:"cfg_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *DisableUserListReq) Reset()         { *m = DisableUserListReq{} }
func (m *DisableUserListReq) String() string { return proto.CompactTextString(m) }
func (*DisableUserListReq) ProtoMessage()    {}
func (*DisableUserListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{26}
}
func (m *DisableUserListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DisableUserListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DisableUserListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DisableUserListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DisableUserListReq.Merge(m, src)
}
func (m *DisableUserListReq) XXX_Size() int {
	return m.Size()
}
func (m *DisableUserListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DisableUserListReq.DiscardUnknown(m)
}

var xxx_messageInfo_DisableUserListReq proto.InternalMessageInfo

func (m *DisableUserListReq) GetOperType() OperationType {
	if m != nil {
		return m.OperType
	}
	return OperationType_invalid_type
}

func (m *DisableUserListReq) GetCfgInfo() []*DisableUserListInfo {
	if m != nil {
		return m.CfgInfo
	}
	return nil
}

type DisableUserListRsp struct {
	CfgInfo              []*DisableUserListInfo `protobuf:"bytes,1,rep,name=cfg_info,json=cfgInfo,proto3" json:"cfg_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *DisableUserListRsp) Reset()         { *m = DisableUserListRsp{} }
func (m *DisableUserListRsp) String() string { return proto.CompactTextString(m) }
func (*DisableUserListRsp) ProtoMessage()    {}
func (*DisableUserListRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{27}
}
func (m *DisableUserListRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DisableUserListRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DisableUserListRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DisableUserListRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DisableUserListRsp.Merge(m, src)
}
func (m *DisableUserListRsp) XXX_Size() int {
	return m.Size()
}
func (m *DisableUserListRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_DisableUserListRsp.DiscardUnknown(m)
}

var xxx_messageInfo_DisableUserListRsp proto.InternalMessageInfo

func (m *DisableUserListRsp) GetCfgInfo() []*DisableUserListInfo {
	if m != nil {
		return m.CfgInfo
	}
	return nil
}

type InspectCfgReq struct {
	InspectCycle         uint32   `protobuf:"varint,1,opt,name=inspect_cycle,json=inspectCycle,proto3" json:"inspect_cycle,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InspectCfgReq) Reset()         { *m = InspectCfgReq{} }
func (m *InspectCfgReq) String() string { return proto.CompactTextString(m) }
func (*InspectCfgReq) ProtoMessage()    {}
func (*InspectCfgReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{28}
}
func (m *InspectCfgReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InspectCfgReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InspectCfgReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InspectCfgReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InspectCfgReq.Merge(m, src)
}
func (m *InspectCfgReq) XXX_Size() int {
	return m.Size()
}
func (m *InspectCfgReq) XXX_DiscardUnknown() {
	xxx_messageInfo_InspectCfgReq.DiscardUnknown(m)
}

var xxx_messageInfo_InspectCfgReq proto.InternalMessageInfo

func (m *InspectCfgReq) GetInspectCycle() uint32 {
	if m != nil {
		return m.InspectCycle
	}
	return 0
}

//device info
type GetDeviceInfoReq struct {
	IpAddr               []string `protobuf:"bytes,1,rep,name=ip_addr,json=ipAddr,proto3" json:"ip_addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetDeviceInfoReq) Reset()         { *m = GetDeviceInfoReq{} }
func (m *GetDeviceInfoReq) String() string { return proto.CompactTextString(m) }
func (*GetDeviceInfoReq) ProtoMessage()    {}
func (*GetDeviceInfoReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{29}
}
func (m *GetDeviceInfoReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetDeviceInfoReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetDeviceInfoReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetDeviceInfoReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetDeviceInfoReq.Merge(m, src)
}
func (m *GetDeviceInfoReq) XXX_Size() int {
	return m.Size()
}
func (m *GetDeviceInfoReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetDeviceInfoReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetDeviceInfoReq proto.InternalMessageInfo

func (m *GetDeviceInfoReq) GetIpAddr() []string {
	if m != nil {
		return m.IpAddr
	}
	return nil
}

type DeviceStatInfo struct {
	IpAddr               string   `protobuf:"bytes,1,opt,name=ip_addr,json=ipAddr,proto3" json:"ip_addr,omitempty"`
	CpuUsageRate         float32  `protobuf:"fixed32,2,opt,name=cpu_usage_rate,json=cpuUsageRate,proto3" json:"cpu_usage_rate,omitempty"`
	MemoryUsageRate      float32  `protobuf:"fixed32,3,opt,name=memory_usage_rate,json=memoryUsageRate,proto3" json:"memory_usage_rate,omitempty"`
	DiskUsageRate        float32  `protobuf:"fixed32,4,opt,name=disk_usage_rate,json=diskUsageRate,proto3" json:"disk_usage_rate,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeviceStatInfo) Reset()         { *m = DeviceStatInfo{} }
func (m *DeviceStatInfo) String() string { return proto.CompactTextString(m) }
func (*DeviceStatInfo) ProtoMessage()    {}
func (*DeviceStatInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{30}
}
func (m *DeviceStatInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceStatInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceStatInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceStatInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceStatInfo.Merge(m, src)
}
func (m *DeviceStatInfo) XXX_Size() int {
	return m.Size()
}
func (m *DeviceStatInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceStatInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceStatInfo proto.InternalMessageInfo

func (m *DeviceStatInfo) GetIpAddr() string {
	if m != nil {
		return m.IpAddr
	}
	return ""
}

func (m *DeviceStatInfo) GetCpuUsageRate() float32 {
	if m != nil {
		return m.CpuUsageRate
	}
	return 0
}

func (m *DeviceStatInfo) GetMemoryUsageRate() float32 {
	if m != nil {
		return m.MemoryUsageRate
	}
	return 0
}

func (m *DeviceStatInfo) GetDiskUsageRate() float32 {
	if m != nil {
		return m.DiskUsageRate
	}
	return 0
}

type GetDeviceInfoRsp struct {
	StatInfo             []*DeviceStatInfo `protobuf:"bytes,1,rep,name=statInfo,proto3" json:"statInfo,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *GetDeviceInfoRsp) Reset()         { *m = GetDeviceInfoRsp{} }
func (m *GetDeviceInfoRsp) String() string { return proto.CompactTextString(m) }
func (*GetDeviceInfoRsp) ProtoMessage()    {}
func (*GetDeviceInfoRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{31}
}
func (m *GetDeviceInfoRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetDeviceInfoRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetDeviceInfoRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetDeviceInfoRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetDeviceInfoRsp.Merge(m, src)
}
func (m *GetDeviceInfoRsp) XXX_Size() int {
	return m.Size()
}
func (m *GetDeviceInfoRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetDeviceInfoRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GetDeviceInfoRsp proto.InternalMessageInfo

func (m *GetDeviceInfoRsp) GetStatInfo() []*DeviceStatInfo {
	if m != nil {
		return m.StatInfo
	}
	return nil
}

type FingerprintInfo struct {
	Index                uint64       `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Ttl                  uint32       `protobuf:"varint,2,opt,name=ttl,proto3" json:"ttl,omitempty"`
	Options              string       `protobuf:"bytes,3,opt,name=options,proto3" json:"options,omitempty"`
	OptionId             uint32       `protobuf:"varint,4,opt,name=option_id,json=optionId,proto3" json:"option_id,omitempty"`
	OptionValue          string       `protobuf:"bytes,5,opt,name=option_value,json=optionValue,proto3" json:"option_value,omitempty"`
	ProtocolType         ProtocolType `protobuf:"varint,6,opt,name=protocol_type,json=protocolType,proto3,enum=dhcpserver.ProtocolType" json:"protocol_type,omitempty"`
	MessageType          int32        `protobuf:"varint,7,opt,name=message_type,json=messageType,proto3" json:"message_type,omitempty"`
	Supplier             string       `protobuf:"bytes,8,opt,name=supplier,proto3" json:"supplier,omitempty"`
	SystemName           string       `protobuf:"bytes,9,opt,name=system_name,json=systemName,proto3" json:"system_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *FingerprintInfo) Reset()         { *m = FingerprintInfo{} }
func (m *FingerprintInfo) String() string { return proto.CompactTextString(m) }
func (*FingerprintInfo) ProtoMessage()    {}
func (*FingerprintInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{32}
}
func (m *FingerprintInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FingerprintInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FingerprintInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FingerprintInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FingerprintInfo.Merge(m, src)
}
func (m *FingerprintInfo) XXX_Size() int {
	return m.Size()
}
func (m *FingerprintInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FingerprintInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FingerprintInfo proto.InternalMessageInfo

func (m *FingerprintInfo) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *FingerprintInfo) GetTtl() uint32 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

func (m *FingerprintInfo) GetOptions() string {
	if m != nil {
		return m.Options
	}
	return ""
}

func (m *FingerprintInfo) GetOptionId() uint32 {
	if m != nil {
		return m.OptionId
	}
	return 0
}

func (m *FingerprintInfo) GetOptionValue() string {
	if m != nil {
		return m.OptionValue
	}
	return ""
}

func (m *FingerprintInfo) GetProtocolType() ProtocolType {
	if m != nil {
		return m.ProtocolType
	}
	return ProtocolType_invalid_ProtocolType
}

func (m *FingerprintInfo) GetMessageType() int32 {
	if m != nil {
		return m.MessageType
	}
	return 0
}

func (m *FingerprintInfo) GetSupplier() string {
	if m != nil {
		return m.Supplier
	}
	return ""
}

func (m *FingerprintInfo) GetSystemName() string {
	if m != nil {
		return m.SystemName
	}
	return ""
}

type FingerprintReq struct {
	OperType             OperationType      `protobuf:"varint,1,opt,name=oper_type,json=operType,proto3,enum=dhcpserver.OperationType" json:"oper_type,omitempty"`
	CfgInfo              []*FingerprintInfo `protobuf:"bytes,2,rep,name=cfg_info,json=cfgInfo,proto3" json:"cfg_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *FingerprintReq) Reset()         { *m = FingerprintReq{} }
func (m *FingerprintReq) String() string { return proto.CompactTextString(m) }
func (*FingerprintReq) ProtoMessage()    {}
func (*FingerprintReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{33}
}
func (m *FingerprintReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FingerprintReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FingerprintReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FingerprintReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FingerprintReq.Merge(m, src)
}
func (m *FingerprintReq) XXX_Size() int {
	return m.Size()
}
func (m *FingerprintReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FingerprintReq.DiscardUnknown(m)
}

var xxx_messageInfo_FingerprintReq proto.InternalMessageInfo

func (m *FingerprintReq) GetOperType() OperationType {
	if m != nil {
		return m.OperType
	}
	return OperationType_invalid_type
}

func (m *FingerprintReq) GetCfgInfo() []*FingerprintInfo {
	if m != nil {
		return m.CfgInfo
	}
	return nil
}

type FingerprintRsp struct {
	CfgInfo              []*FingerprintInfo `protobuf:"bytes,1,rep,name=cfg_info,json=cfgInfo,proto3" json:"cfg_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *FingerprintRsp) Reset()         { *m = FingerprintRsp{} }
func (m *FingerprintRsp) String() string { return proto.CompactTextString(m) }
func (*FingerprintRsp) ProtoMessage()    {}
func (*FingerprintRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{34}
}
func (m *FingerprintRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FingerprintRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FingerprintRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FingerprintRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FingerprintRsp.Merge(m, src)
}
func (m *FingerprintRsp) XXX_Size() int {
	return m.Size()
}
func (m *FingerprintRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_FingerprintRsp.DiscardUnknown(m)
}

var xxx_messageInfo_FingerprintRsp proto.InternalMessageInfo

func (m *FingerprintRsp) GetCfgInfo() []*FingerprintInfo {
	if m != nil {
		return m.CfgInfo
	}
	return nil
}

type OptionsInfo struct {
	Index                uint64       `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	OptionId             uint32       `protobuf:"varint,2,opt,name=option_id,json=optionId,proto3" json:"option_id,omitempty"`
	OptionName           string       `protobuf:"bytes,3,opt,name=option_name,json=optionName,proto3" json:"option_name,omitempty"`
	OptionValue          string       `protobuf:"bytes,4,opt,name=option_value,json=optionValue,proto3" json:"option_value,omitempty"`
	ProtocolType         ProtocolType `protobuf:"varint,5,opt,name=protocol_type,json=protocolType,proto3,enum=dhcpserver.ProtocolType" json:"protocol_type,omitempty"`
	SubnetId             uint64       `protobuf:"varint,6,opt,name=subnet_id,json=subnetId,proto3" json:"subnet_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *OptionsInfo) Reset()         { *m = OptionsInfo{} }
func (m *OptionsInfo) String() string { return proto.CompactTextString(m) }
func (*OptionsInfo) ProtoMessage()    {}
func (*OptionsInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{35}
}
func (m *OptionsInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OptionsInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OptionsInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OptionsInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OptionsInfo.Merge(m, src)
}
func (m *OptionsInfo) XXX_Size() int {
	return m.Size()
}
func (m *OptionsInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_OptionsInfo.DiscardUnknown(m)
}

var xxx_messageInfo_OptionsInfo proto.InternalMessageInfo

func (m *OptionsInfo) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *OptionsInfo) GetOptionId() uint32 {
	if m != nil {
		return m.OptionId
	}
	return 0
}

func (m *OptionsInfo) GetOptionName() string {
	if m != nil {
		return m.OptionName
	}
	return ""
}

func (m *OptionsInfo) GetOptionValue() string {
	if m != nil {
		return m.OptionValue
	}
	return ""
}

func (m *OptionsInfo) GetProtocolType() ProtocolType {
	if m != nil {
		return m.ProtocolType
	}
	return ProtocolType_invalid_ProtocolType
}

func (m *OptionsInfo) GetSubnetId() uint64 {
	if m != nil {
		return m.SubnetId
	}
	return 0
}

type OptionsReq struct {
	OperType             OperationType  `protobuf:"varint,1,opt,name=oper_type,json=operType,proto3,enum=dhcpserver.OperationType" json:"oper_type,omitempty"`
	Info                 []*OptionsInfo `protobuf:"bytes,2,rep,name=info,proto3" json:"info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *OptionsReq) Reset()         { *m = OptionsReq{} }
func (m *OptionsReq) String() string { return proto.CompactTextString(m) }
func (*OptionsReq) ProtoMessage()    {}
func (*OptionsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{36}
}
func (m *OptionsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OptionsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OptionsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OptionsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OptionsReq.Merge(m, src)
}
func (m *OptionsReq) XXX_Size() int {
	return m.Size()
}
func (m *OptionsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_OptionsReq.DiscardUnknown(m)
}

var xxx_messageInfo_OptionsReq proto.InternalMessageInfo

func (m *OptionsReq) GetOperType() OperationType {
	if m != nil {
		return m.OperType
	}
	return OperationType_invalid_type
}

func (m *OptionsReq) GetInfo() []*OptionsInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

type OptionsRsp struct {
	Info                 []*OptionsInfo `protobuf:"bytes,1,rep,name=info,proto3" json:"info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *OptionsRsp) Reset()         { *m = OptionsRsp{} }
func (m *OptionsRsp) String() string { return proto.CompactTextString(m) }
func (*OptionsRsp) ProtoMessage()    {}
func (*OptionsRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdec62a32a42a996, []int{37}
}
func (m *OptionsRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OptionsRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OptionsRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OptionsRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OptionsRsp.Merge(m, src)
}
func (m *OptionsRsp) XXX_Size() int {
	return m.Size()
}
func (m *OptionsRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_OptionsRsp.DiscardUnknown(m)
}

var xxx_messageInfo_OptionsRsp proto.InternalMessageInfo

func (m *OptionsRsp) GetInfo() []*OptionsInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func init() {
	proto.RegisterEnum("dhcpserver.SubnetType", SubnetType_name, SubnetType_value)
	proto.RegisterEnum("dhcpserver.OperationType", OperationType_name, OperationType_value)
	proto.RegisterEnum("dhcpserver.ListType", ListType_name, ListType_value)
	proto.RegisterEnum("dhcpserver.Status", Status_name, Status_value)
	proto.RegisterEnum("dhcpserver.ServerType", ServerType_name, ServerType_value)
	proto.RegisterEnum("dhcpserver.AuthType", AuthType_name, AuthType_value)
	proto.RegisterEnum("dhcpserver.ProtocolType", ProtocolType_name, ProtocolType_value)
	proto.RegisterType((*ReqStatus)(nil), "dhcpserver.ReqStatus")
	proto.RegisterType((*SubnetInfos)(nil), "dhcpserver.SubnetInfos")
	proto.RegisterType((*SubnetInfo)(nil), "dhcpserver.SubnetInfo")
	proto.RegisterType((*NetworkSegmentInfo)(nil), "dhcpserver.NetworkSegmentInfo")
	proto.RegisterType((*V4SubInfo)(nil), "dhcpserver.V4SubInfo")
	proto.RegisterType((*V6SubInfo)(nil), "dhcpserver.V6SubInfo")
	proto.RegisterType((*PoolInfo)(nil), "dhcpserver.PoolInfo")
	proto.RegisterType((*PDPrefixInfo)(nil), "dhcpserver.PDPrefixInfo")
	proto.RegisterType((*IpStaticInfos)(nil), "dhcpserver.IpStaticInfos")
	proto.RegisterType((*IpStaticInfo)(nil), "dhcpserver.IpStaticInfo")
	proto.RegisterType((*RespResult)(nil), "dhcpserver.RespResult")
	proto.RegisterType((*BlackAndWhiteListInfo)(nil), "dhcpserver.BlackAndWhiteListInfo")
	proto.RegisterType((*BlackAndWhiteListReq)(nil), "dhcpserver.BlackAndWhiteListReq")
	proto.RegisterType((*GetBWListReq)(nil), "dhcpserver.GetBWListReq")
	proto.RegisterType((*GetBWListResp)(nil), "dhcpserver.GetBWListResp")
	proto.RegisterType((*StatusBWListReq)(nil), "dhcpserver.StatusBWListReq")
	proto.RegisterType((*ServerCfgInfo)(nil), "dhcpserver.ServerCfgInfo")
	proto.RegisterType((*SetServerCfgReq)(nil), "dhcpserver.SetServerCfgReq")
	proto.RegisterType((*GetServerCfgReq)(nil), "dhcpserver.GetServerCfgReq")
	proto.RegisterType((*GetServerCfgResp)(nil), "dhcpserver.GetServerCfgResp")
	proto.RegisterType((*AuthCfgInfo)(nil), "dhcpserver.AuthCfgInfo")
	proto.RegisterType((*AuthCfgReq)(nil), "dhcpserver.AuthCfgReq")
	proto.RegisterType((*GetAuthCfgReq)(nil), "dhcpserver.GetAuthCfgReq")
	proto.RegisterType((*GetAuthCfgResp)(nil), "dhcpserver.GetAuthCfgResp")
	proto.RegisterType((*StatusAuthReq)(nil), "dhcpserver.StatusAuthReq")
	proto.RegisterType((*DisableUserListInfo)(nil), "dhcpserver.DisableUserListInfo")
	proto.RegisterType((*DisableUserListReq)(nil), "dhcpserver.DisableUserListReq")
	proto.RegisterType((*DisableUserListRsp)(nil), "dhcpserver.DisableUserListRsp")
	proto.RegisterType((*InspectCfgReq)(nil), "dhcpserver.InspectCfgReq")
	proto.RegisterType((*GetDeviceInfoReq)(nil), "dhcpserver.GetDeviceInfoReq")
	proto.RegisterType((*DeviceStatInfo)(nil), "dhcpserver.DeviceStatInfo")
	proto.RegisterType((*GetDeviceInfoRsp)(nil), "dhcpserver.GetDeviceInfoRsp")
	proto.RegisterType((*FingerprintInfo)(nil), "dhcpserver.FingerprintInfo")
	proto.RegisterType((*FingerprintReq)(nil), "dhcpserver.FingerprintReq")
	proto.RegisterType((*FingerprintRsp)(nil), "dhcpserver.FingerprintRsp")
	proto.RegisterType((*OptionsInfo)(nil), "dhcpserver.OptionsInfo")
	proto.RegisterType((*OptionsReq)(nil), "dhcpserver.OptionsReq")
	proto.RegisterType((*OptionsRsp)(nil), "dhcpserver.OptionsRsp")
}

func init() { proto.RegisterFile("dhcpserver.proto", fileDescriptor_fdec62a32a42a996) }

var fileDescriptor_fdec62a32a42a996 = []byte{
	// 2272 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0x4f, 0x6f, 0xdb, 0xc8,
	0x15, 0x37, 0x65, 0x59, 0x96, 0x9e, 0x44, 0x59, 0x3b, 0xf1, 0xc6, 0x8a, 0xd3, 0x75, 0x1c, 0x6e,
	0xbb, 0x30, 0xbc, 0xed, 0xa2, 0xeb, 0x75, 0xdd, 0x76, 0x91, 0xa4, 0x4d, 0xac, 0x8d, 0xe3, 0x36,
	0x7f, 0x5c, 0x3a, 0x7f, 0x80, 0x5e, 0x54, 0x8a, 0x1c, 0x2b, 0x44, 0x28, 0x92, 0xe1, 0x50, 0x8a,
	0x8d, 0x02, 0xc5, 0xf6, 0x52, 0xb4, 0x97, 0xe6, 0xda, 0x9e, 0xf7, 0xd2, 0xbd, 0xf6, 0x23, 0xf4,
	0xd4, 0x63, 0x3f, 0xc2, 0x22, 0xfd, 0x1c, 0x05, 0x8a, 0xf7, 0x66, 0x28, 0x0d, 0x65, 0x49, 0x76,
	0x60, 0x9f, 0x38, 0xf3, 0x9b, 0x37, 0x6f, 0xde, 0xbc, 0x7f, 0x7c, 0x6f, 0xa0, 0xe1, 0xbd, 0x74,
	0x63, 0xc1, 0x93, 0x01, 0x4f, 0x3e, 0x8b, 0x93, 0x28, 0x8d, 0x18, 0x8c, 0x10, 0xeb, 0x26, 0x54,
	0x6c, 0xfe, 0xfa, 0x30, 0x75, 0xd2, 0xbe, 0x60, 0xcb, 0xb0, 0xe0, 0x87, 0x1e, 0x3f, 0x6e, 0x1a,
	0xeb, 0xc6, 0x46, 0xd1, 0x96, 0x13, 0x4b, 0x40, 0xf5, 0xb0, 0xdf, 0x09, 0x79, 0xba, 0x1f, 0x1e,
	0x45, 0x82, 0xdd, 0x82, 0x5a, 0x14, 0xf3, 0xc4, 0x49, 0x79, 0x3b, 0x3d, 0x89, 0x39, 0xd1, 0xd6,
	0xb7, 0xae, 0x7d, 0xa6, 0x1d, 0xf3, 0x84, 0xd6, 0xfd, 0x28, 0x7c, 0x7a, 0x12, 0x73, 0xbb, 0xaa,
	0xc8, 0x71, 0xc2, 0x3e, 0x81, 0x02, 0x1f, 0x34, 0x0b, 0xeb, 0xf3, 0x1b, 0xd5, 0xad, 0xab, 0xfa,
	0x9e, 0xd1, 0x11, 0x76, 0x81, 0x0f, 0xac, 0x6f, 0x0b, 0x00, 0x23, 0x68, 0xb2, 0x64, 0x8c, 0x41,
	0x31, 0x74, 0x7a, 0xbc, 0x59, 0x58, 0x37, 0x36, 0x2a, 0x36, 0x8d, 0xd9, 0x0a, 0x2c, 0x0e, 0x02,
	0x27, 0x6c, 0xfb, 0x5e, 0x73, 0x7e, 0xdd, 0xd8, 0x58, 0xb0, 0x4b, 0x38, 0xdd, 0xf7, 0xd8, 0x26,
	0x14, 0x49, 0xde, 0x22, 0xc9, 0x3b, 0xe1, 0x6c, 0x12, 0x96, 0x68, 0xd8, 0x8f, 0x60, 0xb1, 0xf3,
	0x46, 0x5e, 0x6f, 0x81, 0xc8, 0x97, 0x75, 0xf2, 0x87, 0xbe, 0x90, 0xc4, 0xa5, 0xce, 0x1b, 0xba,
	0xd4, 0x4d, 0xa8, 0x09, 0x62, 0xd1, 0x1e, 0x38, 0x81, 0xef, 0x35, 0x4b, 0xeb, 0xc6, 0x86, 0x69,
	0x57, 0x25, 0xf6, 0x1c, 0x21, 0xf6, 0x43, 0x28, 0x0d, 0xb6, 0xdb, 0xa2, 0xdf, 0x69, 0x2e, 0xae,
	0x1b, 0x1b, 0xd5, 0xad, 0x0f, 0x75, 0x86, 0xcf, 0xb7, 0x0f, 0xfb, 0x1d, 0xba, 0xfa, 0xc2, 0x00,
	0x87, 0x44, 0xbd, 0x43, 0xd4, 0xe5, 0x09, 0xd4, 0x3b, 0x23, 0x6a, 0x1c, 0x5a, 0xb7, 0x80, 0x3d,
	0xe6, 0xe9, 0x9b, 0x28, 0x79, 0x75, 0xc8, 0xbb, 0x3d, 0x1e, 0xce, 0x52, 0x59, 0x03, 0xe6, 0x43,
	0x9e, 0x2a, 0x8d, 0xe1, 0xd0, 0xea, 0x43, 0x65, 0x78, 0x3e, 0xbb, 0x03, 0x10, 0xf2, 0x54, 0xb1,
	0x69, 0x1a, 0x64, 0xa6, 0x35, 0xfd, 0xf0, 0xd3, 0x07, 0xd9, 0xda, 0x0e, 0xb6, 0x01, 0xc5, 0x38,
	0x8a, 0x82, 0xe6, 0x22, 0xed, 0xcc, 0x69, 0xed, 0x20, 0x8a, 0x02, 0xa2, 0x27, 0x0a, 0xeb, 0x1f,
	0x06, 0x54, 0x86, 0x37, 0xb9, 0xb4, 0x73, 0x8b, 0x67, 0x9d, 0xcb, 0x3e, 0x87, 0xc5, 0xd8, 0x6b,
	0xfb, 0xe1, 0x51, 0x44, 0xa6, 0xad, 0x6e, 0x35, 0x73, 0xc4, 0xad, 0x83, 0x84, 0x1f, 0xf9, 0xc7,
	0xb4, 0xa1, 0x14, 0x7b, 0xf8, 0xb5, 0x5a, 0x50, 0xce, 0x98, 0x4c, 0xd7, 0x6a, 0x87, 0x77, 0xc9,
	0xb5, 0x2a, 0x36, 0x0e, 0x11, 0xe1, 0xa1, 0x47, 0x47, 0x54, 0x6c, 0x1c, 0x5a, 0x07, 0x50, 0xd3,
	0xb9, 0x93, 0xd3, 0xa4, 0x4e, 0x92, 0xb6, 0x63, 0xc2, 0x88, 0x61, 0xc5, 0xae, 0x12, 0x26, 0xc9,
	0xd8, 0x47, 0x00, 0x3c, 0xf4, 0x32, 0x02, 0x69, 0xb3, 0x0a, 0x0f, 0x3d, 0xb9, 0x6c, 0xbd, 0x01,
	0x73, 0x3f, 0xc6, 0xd0, 0xf5, 0xdd, 0xcb, 0x08, 0xcd, 0x0d, 0x2d, 0x34, 0x73, 0x4a, 0xd1, 0x0f,
	0xa1, 0xe0, 0x7c, 0x6b, 0x40, 0x4d, 0x07, 0xa7, 0x68, 0xe5, 0x3a, 0x54, 0x54, 0x58, 0xf8, 0x1e,
	0x49, 0x5f, 0xb4, 0xcb, 0x12, 0xd8, 0xf7, 0x50, 0x41, 0x3d, 0xc7, 0xa5, 0x18, 0xad, 0xd8, 0x38,
	0xc4, 0x68, 0xf6, 0xfa, 0xbe, 0xa7, 0xb4, 0x48, 0x63, 0xc4, 0x06, 0xdb, 0x7e, 0xac, 0xf4, 0x48,
	0x63, 0xc2, 0x76, 0xfc, 0x98, 0xa2, 0x0c, 0xb1, 0x1d, 0x3f, 0xb6, 0x9e, 0x00, 0xd8, 0x5c, 0xc4,
	0x36, 0x17, 0xfd, 0x20, 0x65, 0x37, 0xa0, 0x9a, 0xd0, 0xa8, 0xed, 0x46, 0x9e, 0x54, 0xc3, 0x82,
	0x0d, 0x12, 0xda, 0x8d, 0x3c, 0xce, 0xd6, 0xa1, 0xea, 0x71, 0xe1, 0x26, 0x7e, 0x8c, 0xaa, 0x50,
	0x9a, 0xd5, 0x21, 0xeb, 0x7f, 0x06, 0x7c, 0x78, 0x2f, 0x70, 0xdc, 0x57, 0x77, 0x43, 0xef, 0xc5,
	0x4b, 0x3f, 0xe5, 0x18, 0xf4, 0x33, 0xee, 0xfa, 0x39, 0x54, 0x02, 0x5f, 0xa4, 0x52, 0xef, 0x85,
	0x19, 0x39, 0xa3, 0x1c, 0xa8, 0x11, 0x4a, 0xd9, 0x73, 0xdc, 0xb6, 0xe3, 0x79, 0x09, 0x17, 0x42,
	0x69, 0x02, 0x7a, 0x8e, 0x7b, 0x57, 0x22, 0xa8, 0xbf, 0xbe, 0xe0, 0x49, 0x9b, 0x72, 0x9c, 0xd4,
	0x4a, 0x19, 0x81, 0xc7, 0x98, 0xe7, 0x72, 0xca, 0x5d, 0x18, 0x53, 0xee, 0x32, 0x2c, 0x84, 0x51,
	0xca, 0x85, 0xd2, 0x91, 0x9c, 0xb0, 0x4d, 0x28, 0x09, 0x4a, 0xf4, 0x94, 0x83, 0xea, 0x5b, 0x2c,
	0x97, 0x03, 0x69, 0xc5, 0x56, 0x14, 0xd6, 0x5f, 0x0d, 0x58, 0x3e, 0x75, 0x7f, 0x9b, 0xbf, 0x66,
	0x3b, 0x50, 0x41, 0xa7, 0x39, 0xa7, 0x83, 0x95, 0x91, 0x96, 0x6e, 0x7b, 0x47, 0x29, 0x88, 0x22,
	0x4f, 0x3a, 0xd9, 0x4d, 0x7d, 0xdf, 0x44, 0x65, 0x4b, 0x6d, 0x51, 0x10, 0xbe, 0x80, 0xda, 0x1e,
	0x4f, 0xef, 0xbd, 0xc8, 0xe4, 0xb8, 0x2c, 0x33, 0x58, 0x4f, 0xc0, 0xd4, 0x18, 0x8b, 0x18, 0x25,
	0x4d, 0xb8, 0x88, 0xdb, 0x48, 0xa1, 0x52, 0xd1, 0x79, 0x24, 0xc5, 0x3d, 0x38, 0xb3, 0xfe, 0x64,
	0xc0, 0x92, 0xd4, 0xe6, 0xe5, 0x4b, 0xab, 0xd9, 0x70, 0xfe, 0x4c, 0x1b, 0xfe, 0x6b, 0x1e, 0xcc,
	0x43, 0x5a, 0xd9, 0x3d, 0xea, 0xce, 0xf0, 0xdd, 0x9f, 0x42, 0x55, 0x32, 0xd0, 0x05, 0xc9, 0xff,
	0x20, 0xe9, 0x43, 0xa2, 0x80, 0x18, 0x8e, 0xd9, 0xc7, 0x60, 0x06, 0x91, 0xeb, 0x04, 0x63, 0x3e,
	0x5c, 0x23, 0x30, 0xf3, 0xe2, 0x8f, 0x00, 0x24, 0x51, 0x1c, 0x25, 0x29, 0xb9, 0xb1, 0x69, 0x57,
	0x08, 0x39, 0x88, 0x92, 0x14, 0xd3, 0x60, 0xcc, 0x79, 0x32, 0x64, 0x21, 0x23, 0xbd, 0x8a, 0x98,
	0x16, 0x07, 0x44, 0x42, 0x0c, 0xe4, 0xbf, 0xb5, 0x8c, 0x40, 0xb6, 0xbf, 0x17, 0x85, 0x7e, 0x1a,
	0x25, 0xed, 0xd4, 0xef, 0x71, 0x72, 0xed, 0xa2, 0x5d, 0x55, 0xd8, 0x53, 0xbf, 0x87, 0x89, 0xad,
	0xd1, 0x73, 0x8e, 0xdb, 0xfd, 0xd8, 0xa3, 0xcc, 0xe8, 0xf7, 0xb8, 0xa0, 0xff, 0xaa, 0x69, 0xd7,
	0x7b, 0xce, 0xf1, 0x33, 0x82, 0x91, 0x50, 0xb0, 0x9f, 0xc0, 0x0a, 0x52, 0x06, 0x91, 0xe3, 0xb5,
	0x3b, 0x4e, 0xe0, 0x84, 0xae, 0x1f, 0x76, 0x25, 0xdf, 0x0a, 0xf1, 0x5d, 0xee, 0x39, 0xc7, 0x0f,
	0x23, 0xc7, 0xbb, 0x97, 0x2d, 0xd2, 0x01, 0x5f, 0xc0, 0x55, 0xa7, 0x9f, 0x46, 0xd9, 0x09, 0x01,
	0x77, 0x84, 0x3c, 0xa7, 0x09, 0xb4, 0xeb, 0x0a, 0xae, 0xca, 0x73, 0x1e, 0xe2, 0x1a, 0x6d, 0xfa,
	0x01, 0xd4, 0x05, 0x8f, 0x1d, 0xca, 0xd6, 0x9e, 0xdf, 0xf5, 0xd3, 0x66, 0x95, 0x64, 0x32, 0x33,
	0xb4, 0x85, 0xa0, 0xf5, 0x17, 0xf4, 0x26, 0xfc, 0xd1, 0x29, 0x3b, 0x5e, 0x2c, 0x06, 0x4d, 0x65,
	0x68, 0x37, 0x0a, 0x8f, 0xfc, 0xae, 0x8a, 0xc3, 0x6b, 0xa7, 0x4d, 0xad, 0x1c, 0xc6, 0xae, 0x49,
	0x74, 0x97, 0xc8, 0xad, 0xdf, 0xc1, 0xd2, 0xde, 0x98, 0x28, 0x97, 0xeb, 0x51, 0xd6, 0x63, 0x68,
	0xe4, 0x4f, 0x10, 0x31, 0xfb, 0x92, 0xb2, 0x79, 0xdc, 0x96, 0x64, 0x2a, 0x22, 0x67, 0xc8, 0x8c,
	0x89, 0x3e, 0x96, 0x90, 0xf5, 0xb6, 0x00, 0xd5, 0xbb, 0xfd, 0xf4, 0xe5, 0xec, 0x00, 0xd8, 0x50,
	0xa5, 0xe1, 0x84, 0x10, 0xc4, 0xcd, 0x5a, 0x61, 0x78, 0xb1, 0x9c, 0x7d, 0x03, 0xaa, 0xfc, 0x38,
	0xf6, 0x13, 0xe5, 0x1c, 0x0b, 0x64, 0x6f, 0x90, 0x10, 0xf9, 0xc4, 0x88, 0x00, 0x7d, 0x45, 0x65,
	0x6f, 0x45, 0xd0, 0x72, 0x52, 0x3e, 0x4a, 0xec, 0x8b, 0x93, 0x13, 0x7b, 0xf9, 0xcc, 0xa4, 0xf0,
	0x07, 0x00, 0xa5, 0x90, 0x8b, 0x78, 0xd2, 0xcf, 0xa0, 0xea, 0xf4, 0xd3, 0x97, 0x79, 0x3f, 0x5a,
	0x19, 0x57, 0xdc, 0xd0, 0x22, 0x48, 0xab, 0x7c, 0x48, 0xa6, 0x5b, 0x4d, 0x84, 0x0b, 0x9a, 0xc4,
	0xba, 0x0f, 0x75, 0x9d, 0xa1, 0x88, 0xd9, 0xb6, 0x4a, 0xe0, 0x78, 0xaa, 0x72, 0x97, 0xa9, 0xa2,
	0x51, 0xda, 0x46, 0xc0, 0xfa, 0x3d, 0x98, 0x52, 0x55, 0x38, 0xbb, 0x04, 0xc1, 0xde, 0x2b, 0x55,
	0xfb, 0x70, 0xa5, 0xe5, 0x0b, 0xa7, 0x13, 0xf0, 0x67, 0x82, 0x27, 0x67, 0xd4, 0x1a, 0x63, 0x4e,
	0x58, 0x98, 0xed, 0x84, 0xf3, 0x79, 0x27, 0xb4, 0xfe, 0x6c, 0x00, 0x1b, 0x3b, 0xeb, 0x22, 0x9e,
	0xf0, 0x25, 0x94, 0xdd, 0xa3, 0xae, 0xfe, 0x5b, 0xbf, 0xa1, 0x6f, 0x9b, 0x70, 0x2b, 0x7b, 0xd1,
	0x95, 0xca, 0xb7, 0x0e, 0x4e, 0x4b, 0x42, 0xf1, 0x3e, 0xe2, 0x68, 0xbc, 0x27, 0xc7, 0x6d, 0x30,
	0xf7, 0x43, 0x11, 0x73, 0x37, 0x55, 0xde, 0xf5, 0x31, 0x98, 0xbe, 0x04, 0xda, 0xee, 0x89, 0x1b,
	0xc8, 0xab, 0x99, 0x76, 0x4d, 0x81, 0xbb, 0x88, 0x59, 0x9f, 0x52, 0xd6, 0x69, 0xf1, 0x81, 0xef,
	0x72, 0xe2, 0xc7, 0x5f, 0x63, 0x1f, 0xe9, 0xc7, 0xa4, 0x63, 0x12, 0xa2, 0x62, 0x97, 0xfc, 0x18,
	0xf5, 0x6b, 0x7d, 0x63, 0x40, 0x5d, 0x92, 0xa2, 0x0d, 0xc9, 0x4c, 0x39, 0x5a, 0x63, 0x44, 0xcb,
	0xbe, 0x0f, 0x75, 0x37, 0xee, 0xb7, 0xfb, 0xc2, 0xe9, 0xf2, 0x36, 0xe6, 0x74, 0x32, 0x56, 0xc1,
	0xae, 0xb9, 0x71, 0xff, 0x19, 0x82, 0x36, 0x06, 0xf5, 0x26, 0x7c, 0xd0, 0xe3, 0xbd, 0x28, 0x39,
	0xd1, 0x09, 0xe7, 0x89, 0x70, 0x49, 0x2e, 0x8c, 0x68, 0x3f, 0x81, 0x25, 0xcf, 0x17, 0xaf, 0x74,
	0xca, 0x22, 0x51, 0x9a, 0x08, 0x0f, 0xe9, 0xac, 0x5f, 0x8d, 0x5f, 0x49, 0xc4, 0x6c, 0x07, 0xca,
	0x42, 0x89, 0xac, 0x14, 0xbb, 0x9a, 0x53, 0x6c, 0xee, 0x52, 0xf6, 0x90, 0xd6, 0xfa, 0x67, 0x01,
	0x96, 0xee, 0xfb, 0x61, 0x97, 0x27, 0x71, 0xe2, 0x9f, 0xd5, 0x5d, 0xa6, 0x69, 0x40, 0x97, 0x34,
	0x6d, 0x1c, 0xb2, 0x26, 0x2c, 0x46, 0x54, 0x51, 0x67, 0xc9, 0x32, 0x9b, 0xa2, 0x93, 0xca, 0x61,
	0x5b, 0xd5, 0xfc, 0x26, 0x7a, 0x15, 0x02, 0xfb, 0x1e, 0xfe, 0xd5, 0xd5, 0xe2, 0xc0, 0x09, 0xfa,
	0x3c, 0xab, 0x0a, 0x24, 0xf6, 0x1c, 0x21, 0x76, 0x1b, 0x4c, 0x7a, 0xce, 0x70, 0xa3, 0x40, 0x3a,
	0x6d, 0x89, 0x9c, 0x36, 0xdf, 0xce, 0x29, 0x02, 0xf2, 0xd9, 0x5a, 0xac, 0xcd, 0xa8, 0x6e, 0xe0,
	0x82, 0xb4, 0x48, 0xbb, 0x17, 0xa9, 0x49, 0xa8, 0x2a, 0x8c, 0x48, 0x56, 0xa1, 0x2c, 0xfa, 0x71,
	0x1c, 0xf8, 0x3c, 0xa1, 0xc4, 0x5a, 0xb1, 0x87, 0x73, 0x8c, 0x41, 0x71, 0x22, 0x52, 0xde, 0x93,
	0x41, 0x56, 0x91, 0x31, 0x28, 0x21, 0x0a, 0xb3, 0xaf, 0x0d, 0xa8, 0x6b, 0x4a, 0xbb, 0x48, 0x88,
	0xed, 0x9c, 0x0a, 0xb1, 0xeb, 0xfa, 0xb6, 0x31, 0xd3, 0x8c, 0x82, 0xe1, 0x41, 0x5e, 0x02, 0xe9,
	0x01, 0x63, 0xa1, 0x75, 0x3e, 0x4e, 0xdf, 0x19, 0x50, 0x7d, 0x22, 0xed, 0x36, 0xbb, 0xdf, 0x1b,
	0x59, 0xb4, 0x30, 0x66, 0xd1, 0x1b, 0xa0, 0xac, 0xa7, 0x67, 0x25, 0x90, 0x10, 0xfd, 0x1c, 0xc7,
	0x4d, 0x5e, 0x3c, 0x87, 0xc9, 0x17, 0xde, 0xcb, 0xe4, 0xb9, 0x96, 0xa9, 0x94, 0x6f, 0x99, 0xac,
	0xd7, 0x00, 0xea, 0x86, 0x17, 0x31, 0xd5, 0xa7, 0x50, 0xd4, 0xcc, 0xb4, 0x92, 0xdf, 0x32, 0xd4,
	0x9f, 0x4d, 0x44, 0xd6, 0xcf, 0x47, 0x47, 0x8a, 0x78, 0xb8, 0xd5, 0x38, 0xc7, 0xd6, 0xcd, 0x56,
	0xf6, 0x3a, 0x46, 0xa7, 0x32, 0xa8, 0xfb, 0x21, 0x3d, 0x3d, 0xb5, 0xe5, 0x7d, 0x1a, 0x73, 0x6c,
	0x49, 0xfd, 0xa1, 0x15, 0x60, 0xb0, 0x0f, 0xc0, 0x74, 0x5c, 0x97, 0x0b, 0x91, 0x41, 0x85, 0xcd,
	0xdf, 0x80, 0x99, 0xbb, 0x08, 0x6b, 0x40, 0x2d, 0x63, 0x84, 0x37, 0x6f, 0xcc, 0xb1, 0x1a, 0x94,
	0x1d, 0x4f, 0xcd, 0x0c, 0x64, 0xea, 0xf1, 0x80, 0xab, 0xf7, 0x85, 0x46, 0x01, 0x81, 0x5e, 0xe4,
	0xf9, 0x47, 0x27, 0x12, 0x98, 0xdf, 0xbc, 0x05, 0xe5, 0xac, 0x6b, 0xd1, 0xb9, 0x61, 0xff, 0xd2,
	0x98, 0x63, 0x75, 0x80, 0x0e, 0x76, 0x4f, 0x72, 0x6e, 0xe0, 0xfc, 0x0d, 0x76, 0x51, 0x72, 0x5e,
	0xd8, 0xdc, 0x85, 0x92, 0x7a, 0x8a, 0xd4, 0xaf, 0x44, 0x48, 0x63, 0x0e, 0x6f, 0xc0, 0x43, 0xcc,
	0xfd, 0x19, 0x64, 0x20, 0x99, 0x27, 0xff, 0x07, 0x88, 0xf5, 0x53, 0xd1, 0x28, 0x6c, 0x7e, 0x05,
	0x30, 0xaa, 0x2e, 0x73, 0x8c, 0x08, 0x95, 0x8c, 0x7a, 0x8e, 0x48, 0x79, 0x92, 0x41, 0x06, 0xca,
	0x2a, 0x02, 0x67, 0xc0, 0x33, 0xa4, 0xb0, 0xd9, 0x82, 0x72, 0xf6, 0x43, 0xd7, 0x6f, 0x82, 0x4a,
	0x6d, 0xcc, 0x21, 0xdb, 0x98, 0x27, 0x31, 0x4f, 0xfb, 0xd8, 0xfe, 0x20, 0x46, 0xc2, 0xa4, 0xbc,
	0x17, 0x47, 0x89, 0x93, 0x9c, 0x48, 0xac, 0xb0, 0xf9, 0x5b, 0xa8, 0xe9, 0x1e, 0xc9, 0x9a, 0xb0,
	0x9c, 0x71, 0xd2, 0xf1, 0xc6, 0x1c, 0x5b, 0x81, 0x2b, 0xad, 0x07, 0xbb, 0x07, 0x83, 0xed, 0xfc,
	0x82, 0x31, 0x5c, 0xd8, 0xc9, 0x2f, 0x14, 0xb6, 0xfe, 0x5e, 0x90, 0xfd, 0x9d, 0xef, 0x72, 0x59,
	0x5c, 0xb1, 0xdb, 0x50, 0xc1, 0xf2, 0x99, 0xec, 0xcb, 0x72, 0x8f, 0x86, 0xc3, 0x47, 0xde, 0xd5,
	0x95, 0xc9, 0xaf, 0xae, 0xc2, 0x9a, 0x63, 0xf7, 0x32, 0x7f, 0xe0, 0x8a, 0xc5, 0x34, 0xda, 0xd5,
	0xab, 0x79, 0xde, 0xd9, 0xcb, 0x8b, 0x35, 0xc7, 0x7e, 0x21, 0x45, 0xa0, 0xb7, 0xa1, 0x69, 0x22,
	0x5c, 0x9b, 0xf6, 0xba, 0x84, 0x42, 0xb4, 0x46, 0x42, 0x48, 0x26, 0xd3, 0xa9, 0xa7, 0x8b, 0xb1,
	0xf5, 0x75, 0x01, 0xcc, 0xbb, 0xe4, 0xee, 0xbb, 0x51, 0x98, 0x26, 0x51, 0xc0, 0x9e, 0xc2, 0xf2,
	0x21, 0x4f, 0x4f, 0x35, 0xef, 0x6c, 0x7d, 0x66, 0x6f, 0x6f, 0xf3, 0xd7, 0xd3, 0x4f, 0xd9, 0x30,
	0xd8, 0x13, 0x58, 0xde, 0x9b, 0xc4, 0x35, 0x97, 0x93, 0xf4, 0x87, 0x8b, 0xfc, 0xe5, 0x73, 0x2f,
	0x0f, 0xd6, 0xdc, 0x8f, 0x0d, 0xf6, 0x80, 0xda, 0x3d, 0x09, 0xaa, 0x58, 0xb8, 0x7e, 0xba, 0x70,
	0x1c, 0xb1, 0x9b, 0xae, 0x82, 0x6f, 0x0d, 0x58, 0xba, 0xef, 0xf8, 0x41, 0x34, 0xe0, 0xc9, 0x23,
	0x27, 0x74, 0xba, 0x3c, 0x61, 0x7b, 0x50, 0xd3, 0x9b, 0xc9, 0x31, 0xd6, 0xf9, 0xde, 0x6e, 0xe6,
	0xbd, 0x1f, 0xd1, 0x73, 0xcc, 0x14, 0x46, 0x63, 0x4d, 0xe2, 0xea, 0xf7, 0xa6, 0x2f, 0xca, 0x5b,
	0x6f, 0xfd, 0x71, 0x5e, 0xf6, 0x69, 0x99, 0x9c, 0xbf, 0xc4, 0x18, 0xce, 0x8a, 0x7a, 0x76, 0x75,
	0x42, 0xf5, 0x7e, 0x96, 0x80, 0x7b, 0x00, 0xa3, 0xb6, 0x80, 0x8d, 0x2b, 0x5d, 0x63, 0xb2, 0x3a,
	0x6d, 0x49, 0x19, 0xa4, 0x85, 0x41, 0x46, 0xa8, 0x32, 0xc7, 0xb5, 0xd3, 0xe6, 0x50, 0x2d, 0xc3,
	0x8c, 0xb0, 0x38, 0x00, 0x76, 0xc8, 0xd3, 0xb1, 0xda, 0x95, 0xad, 0xcd, 0x28, 0x6c, 0xcf, 0xf6,
	0x3c, 0xb6, 0x77, 0x9a, 0xe3, 0x94, 0x88, 0x9b, 0x79, 0x90, 0xb2, 0xc1, 0x11, 0xac, 0xa8, 0x06,
	0xc2, 0xe6, 0x6e, 0x14, 0xba, 0x7e, 0xc0, 0x33, 0x73, 0xfc, 0x9a, 0x62, 0x47, 0xad, 0x8e, 0x0a,
	0xec, 0xb1, 0xd0, 0xd4, 0x0b, 0xef, 0x19, 0x7e, 0xd9, 0x81, 0x0f, 0x64, 0xa9, 0x79, 0xc0, 0x93,
	0xa3, 0x28, 0xe9, 0x39, 0xa1, 0xcb, 0xd9, 0x23, 0x6a, 0x0b, 0x47, 0xf5, 0x2a, 0x1b, 0xf7, 0x99,
	0x5c, 0x75, 0xbe, 0x3a, 0x63, 0x15, 0x6f, 0xb3, 0xf5, 0x8d, 0x01, 0x4c, 0xab, 0x66, 0xb2, 0x7b,
	0xdc, 0x87, 0xfa, 0x21, 0x4f, 0xb5, 0x05, 0xb6, 0x3a, 0xa5, 0xfe, 0x99, 0x6d, 0xcd, 0xaf, 0xa8,
	0xe7, 0xd4, 0xf9, 0x4c, 0xd1, 0xfb, 0x54, 0xf6, 0x24, 0xe5, 0x5b, 0x03, 0xea, 0xea, 0xdf, 0x9e,
	0x49, 0x78, 0x87, 0x1c, 0x5f, 0x81, 0x79, 0xc7, 0x1f, 0x95, 0x27, 0x33, 0x24, 0xbb, 0x4d, 0x6e,
	0x9f, 0xed, 0x9f, 0x22, 0xd5, 0x44, 0xb6, 0x28, 0xd1, 0xbd, 0xc6, 0xbf, 0xdf, 0xad, 0x19, 0xff,
	0x79, 0xb7, 0x66, 0x7c, 0xf7, 0x6e, 0xcd, 0xf8, 0xdb, 0x7f, 0xd7, 0xe6, 0x3a, 0x25, 0x2a, 0xa1,
	0xbe, 0xf8, 0x7f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x39, 0x0e, 0x17, 0xcc, 0x47, 0x1c, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ServiceConfigClient is the client API for ServiceConfig service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ServiceConfigClient interface {
	//子网列表
	GetSubnet(ctx context.Context, in *ReqStatus, opts ...grpc.CallOption) (*SubnetInfos, error)
	OperateSubnet(ctx context.Context, in *SubnetInfos, opts ...grpc.CallOption) (*RespResult, error)
	//IPv4/IPv6静态绑定
	GetStatic(ctx context.Context, in *ReqStatus, opts ...grpc.CallOption) (*IpStaticInfos, error)
	OperateStatic(ctx context.Context, in *IpStaticInfos, opts ...grpc.CallOption) (*RespResult, error)
}

type serviceConfigClient struct {
	cc *grpc.ClientConn
}

func NewServiceConfigClient(cc *grpc.ClientConn) ServiceConfigClient {
	return &serviceConfigClient{cc}
}

func (c *serviceConfigClient) GetSubnet(ctx context.Context, in *ReqStatus, opts ...grpc.CallOption) (*SubnetInfos, error) {
	out := new(SubnetInfos)
	err := c.cc.Invoke(ctx, "/dhcpserver.ServiceConfig/GetSubnet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceConfigClient) OperateSubnet(ctx context.Context, in *SubnetInfos, opts ...grpc.CallOption) (*RespResult, error) {
	out := new(RespResult)
	err := c.cc.Invoke(ctx, "/dhcpserver.ServiceConfig/OperateSubnet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceConfigClient) GetStatic(ctx context.Context, in *ReqStatus, opts ...grpc.CallOption) (*IpStaticInfos, error) {
	out := new(IpStaticInfos)
	err := c.cc.Invoke(ctx, "/dhcpserver.ServiceConfig/GetStatic", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceConfigClient) OperateStatic(ctx context.Context, in *IpStaticInfos, opts ...grpc.CallOption) (*RespResult, error) {
	out := new(RespResult)
	err := c.cc.Invoke(ctx, "/dhcpserver.ServiceConfig/OperateStatic", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ServiceConfigServer is the server API for ServiceConfig service.
type ServiceConfigServer interface {
	//子网列表
	GetSubnet(context.Context, *ReqStatus) (*SubnetInfos, error)
	OperateSubnet(context.Context, *SubnetInfos) (*RespResult, error)
	//IPv4/IPv6静态绑定
	GetStatic(context.Context, *ReqStatus) (*IpStaticInfos, error)
	OperateStatic(context.Context, *IpStaticInfos) (*RespResult, error)
}

// UnimplementedServiceConfigServer can be embedded to have forward compatible implementations.
type UnimplementedServiceConfigServer struct {
}

func (*UnimplementedServiceConfigServer) GetSubnet(ctx context.Context, req *ReqStatus) (*SubnetInfos, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSubnet not implemented")
}
func (*UnimplementedServiceConfigServer) OperateSubnet(ctx context.Context, req *SubnetInfos) (*RespResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OperateSubnet not implemented")
}
func (*UnimplementedServiceConfigServer) GetStatic(ctx context.Context, req *ReqStatus) (*IpStaticInfos, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStatic not implemented")
}
func (*UnimplementedServiceConfigServer) OperateStatic(ctx context.Context, req *IpStaticInfos) (*RespResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OperateStatic not implemented")
}

func RegisterServiceConfigServer(s *grpc.Server, srv ServiceConfigServer) {
	s.RegisterService(&_ServiceConfig_serviceDesc, srv)
}

func _ServiceConfig_GetSubnet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceConfigServer).GetSubnet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dhcpserver.ServiceConfig/GetSubnet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceConfigServer).GetSubnet(ctx, req.(*ReqStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceConfig_OperateSubnet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubnetInfos)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceConfigServer).OperateSubnet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dhcpserver.ServiceConfig/OperateSubnet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceConfigServer).OperateSubnet(ctx, req.(*SubnetInfos))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceConfig_GetStatic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceConfigServer).GetStatic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dhcpserver.ServiceConfig/GetStatic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceConfigServer).GetStatic(ctx, req.(*ReqStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceConfig_OperateStatic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IpStaticInfos)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceConfigServer).OperateStatic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dhcpserver.ServiceConfig/OperateStatic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceConfigServer).OperateStatic(ctx, req.(*IpStaticInfos))
	}
	return interceptor(ctx, in, info, handler)
}

var _ServiceConfig_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dhcpserver.ServiceConfig",
	HandlerType: (*ServiceConfigServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSubnet",
			Handler:    _ServiceConfig_GetSubnet_Handler,
		},
		{
			MethodName: "OperateSubnet",
			Handler:    _ServiceConfig_OperateSubnet_Handler,
		},
		{
			MethodName: "GetStatic",
			Handler:    _ServiceConfig_GetStatic_Handler,
		},
		{
			MethodName: "OperateStatic",
			Handler:    _ServiceConfig_OperateStatic_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dhcpserver.proto",
}

// AccessControlClient is the client API for AccessControl service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AccessControlClient interface {
	SetBlackAndWhiteList(ctx context.Context, opts ...grpc.CallOption) (AccessControl_SetBlackAndWhiteListClient, error)
	GetBlackAndWhiteList(ctx context.Context, in *GetBWListReq, opts ...grpc.CallOption) (AccessControl_GetBlackAndWhiteListClient, error)
	SetBWListStatus(ctx context.Context, in *StatusBWListReq, opts ...grpc.CallOption) (*RespResult, error)
}

type accessControlClient struct {
	cc *grpc.ClientConn
}

func NewAccessControlClient(cc *grpc.ClientConn) AccessControlClient {
	return &accessControlClient{cc}
}

func (c *accessControlClient) SetBlackAndWhiteList(ctx context.Context, opts ...grpc.CallOption) (AccessControl_SetBlackAndWhiteListClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AccessControl_serviceDesc.Streams[0], "/dhcpserver.AccessControl/SetBlackAndWhiteList", opts...)
	if err != nil {
		return nil, err
	}
	x := &accessControlSetBlackAndWhiteListClient{stream}
	return x, nil
}

type AccessControl_SetBlackAndWhiteListClient interface {
	Send(*BlackAndWhiteListReq) error
	CloseAndRecv() (*RespResult, error)
	grpc.ClientStream
}

type accessControlSetBlackAndWhiteListClient struct {
	grpc.ClientStream
}

func (x *accessControlSetBlackAndWhiteListClient) Send(m *BlackAndWhiteListReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *accessControlSetBlackAndWhiteListClient) CloseAndRecv() (*RespResult, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(RespResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *accessControlClient) GetBlackAndWhiteList(ctx context.Context, in *GetBWListReq, opts ...grpc.CallOption) (AccessControl_GetBlackAndWhiteListClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AccessControl_serviceDesc.Streams[1], "/dhcpserver.AccessControl/GetBlackAndWhiteList", opts...)
	if err != nil {
		return nil, err
	}
	x := &accessControlGetBlackAndWhiteListClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AccessControl_GetBlackAndWhiteListClient interface {
	Recv() (*GetBWListResp, error)
	grpc.ClientStream
}

type accessControlGetBlackAndWhiteListClient struct {
	grpc.ClientStream
}

func (x *accessControlGetBlackAndWhiteListClient) Recv() (*GetBWListResp, error) {
	m := new(GetBWListResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *accessControlClient) SetBWListStatus(ctx context.Context, in *StatusBWListReq, opts ...grpc.CallOption) (*RespResult, error) {
	out := new(RespResult)
	err := c.cc.Invoke(ctx, "/dhcpserver.AccessControl/SetBWListStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AccessControlServer is the server API for AccessControl service.
type AccessControlServer interface {
	SetBlackAndWhiteList(AccessControl_SetBlackAndWhiteListServer) error
	GetBlackAndWhiteList(*GetBWListReq, AccessControl_GetBlackAndWhiteListServer) error
	SetBWListStatus(context.Context, *StatusBWListReq) (*RespResult, error)
}

// UnimplementedAccessControlServer can be embedded to have forward compatible implementations.
type UnimplementedAccessControlServer struct {
}

func (*UnimplementedAccessControlServer) SetBlackAndWhiteList(srv AccessControl_SetBlackAndWhiteListServer) error {
	return status.Errorf(codes.Unimplemented, "method SetBlackAndWhiteList not implemented")
}
func (*UnimplementedAccessControlServer) GetBlackAndWhiteList(req *GetBWListReq, srv AccessControl_GetBlackAndWhiteListServer) error {
	return status.Errorf(codes.Unimplemented, "method GetBlackAndWhiteList not implemented")
}
func (*UnimplementedAccessControlServer) SetBWListStatus(ctx context.Context, req *StatusBWListReq) (*RespResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetBWListStatus not implemented")
}

func RegisterAccessControlServer(s *grpc.Server, srv AccessControlServer) {
	s.RegisterService(&_AccessControl_serviceDesc, srv)
}

func _AccessControl_SetBlackAndWhiteList_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AccessControlServer).SetBlackAndWhiteList(&accessControlSetBlackAndWhiteListServer{stream})
}

type AccessControl_SetBlackAndWhiteListServer interface {
	SendAndClose(*RespResult) error
	Recv() (*BlackAndWhiteListReq, error)
	grpc.ServerStream
}

type accessControlSetBlackAndWhiteListServer struct {
	grpc.ServerStream
}

func (x *accessControlSetBlackAndWhiteListServer) SendAndClose(m *RespResult) error {
	return x.ServerStream.SendMsg(m)
}

func (x *accessControlSetBlackAndWhiteListServer) Recv() (*BlackAndWhiteListReq, error) {
	m := new(BlackAndWhiteListReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _AccessControl_GetBlackAndWhiteList_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetBWListReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AccessControlServer).GetBlackAndWhiteList(m, &accessControlGetBlackAndWhiteListServer{stream})
}

type AccessControl_GetBlackAndWhiteListServer interface {
	Send(*GetBWListResp) error
	grpc.ServerStream
}

type accessControlGetBlackAndWhiteListServer struct {
	grpc.ServerStream
}

func (x *accessControlGetBlackAndWhiteListServer) Send(m *GetBWListResp) error {
	return x.ServerStream.SendMsg(m)
}

func _AccessControl_SetBWListStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatusBWListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccessControlServer).SetBWListStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dhcpserver.AccessControl/SetBWListStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccessControlServer).SetBWListStatus(ctx, req.(*StatusBWListReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _AccessControl_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dhcpserver.AccessControl",
	HandlerType: (*AccessControlServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetBWListStatus",
			Handler:    _AccessControl_SetBWListStatus_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SetBlackAndWhiteList",
			Handler:       _AccessControl_SetBlackAndWhiteList_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "GetBlackAndWhiteList",
			Handler:       _AccessControl_GetBlackAndWhiteList_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "dhcpserver.proto",
}

// FailoverManagerClient is the client API for FailoverManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type FailoverManagerClient interface {
	SetServerCfg(ctx context.Context, opts ...grpc.CallOption) (FailoverManager_SetServerCfgClient, error)
	GetServerCfg(ctx context.Context, in *GetServerCfgReq, opts ...grpc.CallOption) (FailoverManager_GetServerCfgClient, error)
}

type failoverManagerClient struct {
	cc *grpc.ClientConn
}

func NewFailoverManagerClient(cc *grpc.ClientConn) FailoverManagerClient {
	return &failoverManagerClient{cc}
}

func (c *failoverManagerClient) SetServerCfg(ctx context.Context, opts ...grpc.CallOption) (FailoverManager_SetServerCfgClient, error) {
	stream, err := c.cc.NewStream(ctx, &_FailoverManager_serviceDesc.Streams[0], "/dhcpserver.FailoverManager/SetServerCfg", opts...)
	if err != nil {
		return nil, err
	}
	x := &failoverManagerSetServerCfgClient{stream}
	return x, nil
}

type FailoverManager_SetServerCfgClient interface {
	Send(*SetServerCfgReq) error
	CloseAndRecv() (*RespResult, error)
	grpc.ClientStream
}

type failoverManagerSetServerCfgClient struct {
	grpc.ClientStream
}

func (x *failoverManagerSetServerCfgClient) Send(m *SetServerCfgReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *failoverManagerSetServerCfgClient) CloseAndRecv() (*RespResult, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(RespResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *failoverManagerClient) GetServerCfg(ctx context.Context, in *GetServerCfgReq, opts ...grpc.CallOption) (FailoverManager_GetServerCfgClient, error) {
	stream, err := c.cc.NewStream(ctx, &_FailoverManager_serviceDesc.Streams[1], "/dhcpserver.FailoverManager/GetServerCfg", opts...)
	if err != nil {
		return nil, err
	}
	x := &failoverManagerGetServerCfgClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FailoverManager_GetServerCfgClient interface {
	Recv() (*GetServerCfgResp, error)
	grpc.ClientStream
}

type failoverManagerGetServerCfgClient struct {
	grpc.ClientStream
}

func (x *failoverManagerGetServerCfgClient) Recv() (*GetServerCfgResp, error) {
	m := new(GetServerCfgResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// FailoverManagerServer is the server API for FailoverManager service.
type FailoverManagerServer interface {
	SetServerCfg(FailoverManager_SetServerCfgServer) error
	GetServerCfg(*GetServerCfgReq, FailoverManager_GetServerCfgServer) error
}

// UnimplementedFailoverManagerServer can be embedded to have forward compatible implementations.
type UnimplementedFailoverManagerServer struct {
}

func (*UnimplementedFailoverManagerServer) SetServerCfg(srv FailoverManager_SetServerCfgServer) error {
	return status.Errorf(codes.Unimplemented, "method SetServerCfg not implemented")
}
func (*UnimplementedFailoverManagerServer) GetServerCfg(req *GetServerCfgReq, srv FailoverManager_GetServerCfgServer) error {
	return status.Errorf(codes.Unimplemented, "method GetServerCfg not implemented")
}

func RegisterFailoverManagerServer(s *grpc.Server, srv FailoverManagerServer) {
	s.RegisterService(&_FailoverManager_serviceDesc, srv)
}

func _FailoverManager_SetServerCfg_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(FailoverManagerServer).SetServerCfg(&failoverManagerSetServerCfgServer{stream})
}

type FailoverManager_SetServerCfgServer interface {
	SendAndClose(*RespResult) error
	Recv() (*SetServerCfgReq, error)
	grpc.ServerStream
}

type failoverManagerSetServerCfgServer struct {
	grpc.ServerStream
}

func (x *failoverManagerSetServerCfgServer) SendAndClose(m *RespResult) error {
	return x.ServerStream.SendMsg(m)
}

func (x *failoverManagerSetServerCfgServer) Recv() (*SetServerCfgReq, error) {
	m := new(SetServerCfgReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _FailoverManager_GetServerCfg_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetServerCfgReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FailoverManagerServer).GetServerCfg(m, &failoverManagerGetServerCfgServer{stream})
}

type FailoverManager_GetServerCfgServer interface {
	Send(*GetServerCfgResp) error
	grpc.ServerStream
}

type failoverManagerGetServerCfgServer struct {
	grpc.ServerStream
}

func (x *failoverManagerGetServerCfgServer) Send(m *GetServerCfgResp) error {
	return x.ServerStream.SendMsg(m)
}

var _FailoverManager_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dhcpserver.FailoverManager",
	HandlerType: (*FailoverManagerServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SetServerCfg",
			Handler:       _FailoverManager_SetServerCfg_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "GetServerCfg",
			Handler:       _FailoverManager_GetServerCfg_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "dhcpserver.proto",
}

// AuthManagerClient is the client API for AuthManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AuthManagerClient interface {
	SetAuthCfg(ctx context.Context, opts ...grpc.CallOption) (AuthManager_SetAuthCfgClient, error)
	GetAuthCfg(ctx context.Context, in *GetAuthCfgReq, opts ...grpc.CallOption) (AuthManager_GetAuthCfgClient, error)
	SetAuthStatus(ctx context.Context, in *StatusAuthReq, opts ...grpc.CallOption) (*RespResult, error)
	SetDisableUserList(ctx context.Context, opts ...grpc.CallOption) (AuthManager_SetDisableUserListClient, error)
	GetDisableUserList(ctx context.Context, in *ReqStatus, opts ...grpc.CallOption) (AuthManager_GetDisableUserListClient, error)
}

type authManagerClient struct {
	cc *grpc.ClientConn
}

func NewAuthManagerClient(cc *grpc.ClientConn) AuthManagerClient {
	return &authManagerClient{cc}
}

func (c *authManagerClient) SetAuthCfg(ctx context.Context, opts ...grpc.CallOption) (AuthManager_SetAuthCfgClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AuthManager_serviceDesc.Streams[0], "/dhcpserver.AuthManager/SetAuthCfg", opts...)
	if err != nil {
		return nil, err
	}
	x := &authManagerSetAuthCfgClient{stream}
	return x, nil
}

type AuthManager_SetAuthCfgClient interface {
	Send(*AuthCfgReq) error
	CloseAndRecv() (*RespResult, error)
	grpc.ClientStream
}

type authManagerSetAuthCfgClient struct {
	grpc.ClientStream
}

func (x *authManagerSetAuthCfgClient) Send(m *AuthCfgReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *authManagerSetAuthCfgClient) CloseAndRecv() (*RespResult, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(RespResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *authManagerClient) GetAuthCfg(ctx context.Context, in *GetAuthCfgReq, opts ...grpc.CallOption) (AuthManager_GetAuthCfgClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AuthManager_serviceDesc.Streams[1], "/dhcpserver.AuthManager/GetAuthCfg", opts...)
	if err != nil {
		return nil, err
	}
	x := &authManagerGetAuthCfgClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AuthManager_GetAuthCfgClient interface {
	Recv() (*GetAuthCfgResp, error)
	grpc.ClientStream
}

type authManagerGetAuthCfgClient struct {
	grpc.ClientStream
}

func (x *authManagerGetAuthCfgClient) Recv() (*GetAuthCfgResp, error) {
	m := new(GetAuthCfgResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *authManagerClient) SetAuthStatus(ctx context.Context, in *StatusAuthReq, opts ...grpc.CallOption) (*RespResult, error) {
	out := new(RespResult)
	err := c.cc.Invoke(ctx, "/dhcpserver.AuthManager/SetAuthStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authManagerClient) SetDisableUserList(ctx context.Context, opts ...grpc.CallOption) (AuthManager_SetDisableUserListClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AuthManager_serviceDesc.Streams[2], "/dhcpserver.AuthManager/SetDisableUserList", opts...)
	if err != nil {
		return nil, err
	}
	x := &authManagerSetDisableUserListClient{stream}
	return x, nil
}

type AuthManager_SetDisableUserListClient interface {
	Send(*DisableUserListReq) error
	CloseAndRecv() (*RespResult, error)
	grpc.ClientStream
}

type authManagerSetDisableUserListClient struct {
	grpc.ClientStream
}

func (x *authManagerSetDisableUserListClient) Send(m *DisableUserListReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *authManagerSetDisableUserListClient) CloseAndRecv() (*RespResult, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(RespResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *authManagerClient) GetDisableUserList(ctx context.Context, in *ReqStatus, opts ...grpc.CallOption) (AuthManager_GetDisableUserListClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AuthManager_serviceDesc.Streams[3], "/dhcpserver.AuthManager/GetDisableUserList", opts...)
	if err != nil {
		return nil, err
	}
	x := &authManagerGetDisableUserListClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AuthManager_GetDisableUserListClient interface {
	Recv() (*DisableUserListRsp, error)
	grpc.ClientStream
}

type authManagerGetDisableUserListClient struct {
	grpc.ClientStream
}

func (x *authManagerGetDisableUserListClient) Recv() (*DisableUserListRsp, error) {
	m := new(DisableUserListRsp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// AuthManagerServer is the server API for AuthManager service.
type AuthManagerServer interface {
	SetAuthCfg(AuthManager_SetAuthCfgServer) error
	GetAuthCfg(*GetAuthCfgReq, AuthManager_GetAuthCfgServer) error
	SetAuthStatus(context.Context, *StatusAuthReq) (*RespResult, error)
	SetDisableUserList(AuthManager_SetDisableUserListServer) error
	GetDisableUserList(*ReqStatus, AuthManager_GetDisableUserListServer) error
}

// UnimplementedAuthManagerServer can be embedded to have forward compatible implementations.
type UnimplementedAuthManagerServer struct {
}

func (*UnimplementedAuthManagerServer) SetAuthCfg(srv AuthManager_SetAuthCfgServer) error {
	return status.Errorf(codes.Unimplemented, "method SetAuthCfg not implemented")
}
func (*UnimplementedAuthManagerServer) GetAuthCfg(req *GetAuthCfgReq, srv AuthManager_GetAuthCfgServer) error {
	return status.Errorf(codes.Unimplemented, "method GetAuthCfg not implemented")
}
func (*UnimplementedAuthManagerServer) SetAuthStatus(ctx context.Context, req *StatusAuthReq) (*RespResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAuthStatus not implemented")
}
func (*UnimplementedAuthManagerServer) SetDisableUserList(srv AuthManager_SetDisableUserListServer) error {
	return status.Errorf(codes.Unimplemented, "method SetDisableUserList not implemented")
}
func (*UnimplementedAuthManagerServer) GetDisableUserList(req *ReqStatus, srv AuthManager_GetDisableUserListServer) error {
	return status.Errorf(codes.Unimplemented, "method GetDisableUserList not implemented")
}

func RegisterAuthManagerServer(s *grpc.Server, srv AuthManagerServer) {
	s.RegisterService(&_AuthManager_serviceDesc, srv)
}

func _AuthManager_SetAuthCfg_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AuthManagerServer).SetAuthCfg(&authManagerSetAuthCfgServer{stream})
}

type AuthManager_SetAuthCfgServer interface {
	SendAndClose(*RespResult) error
	Recv() (*AuthCfgReq, error)
	grpc.ServerStream
}

type authManagerSetAuthCfgServer struct {
	grpc.ServerStream
}

func (x *authManagerSetAuthCfgServer) SendAndClose(m *RespResult) error {
	return x.ServerStream.SendMsg(m)
}

func (x *authManagerSetAuthCfgServer) Recv() (*AuthCfgReq, error) {
	m := new(AuthCfgReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _AuthManager_GetAuthCfg_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetAuthCfgReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AuthManagerServer).GetAuthCfg(m, &authManagerGetAuthCfgServer{stream})
}

type AuthManager_GetAuthCfgServer interface {
	Send(*GetAuthCfgResp) error
	grpc.ServerStream
}

type authManagerGetAuthCfgServer struct {
	grpc.ServerStream
}

func (x *authManagerGetAuthCfgServer) Send(m *GetAuthCfgResp) error {
	return x.ServerStream.SendMsg(m)
}

func _AuthManager_SetAuthStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatusAuthReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthManagerServer).SetAuthStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dhcpserver.AuthManager/SetAuthStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthManagerServer).SetAuthStatus(ctx, req.(*StatusAuthReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthManager_SetDisableUserList_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AuthManagerServer).SetDisableUserList(&authManagerSetDisableUserListServer{stream})
}

type AuthManager_SetDisableUserListServer interface {
	SendAndClose(*RespResult) error
	Recv() (*DisableUserListReq, error)
	grpc.ServerStream
}

type authManagerSetDisableUserListServer struct {
	grpc.ServerStream
}

func (x *authManagerSetDisableUserListServer) SendAndClose(m *RespResult) error {
	return x.ServerStream.SendMsg(m)
}

func (x *authManagerSetDisableUserListServer) Recv() (*DisableUserListReq, error) {
	m := new(DisableUserListReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _AuthManager_GetDisableUserList_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReqStatus)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AuthManagerServer).GetDisableUserList(m, &authManagerGetDisableUserListServer{stream})
}

type AuthManager_GetDisableUserListServer interface {
	Send(*DisableUserListRsp) error
	grpc.ServerStream
}

type authManagerGetDisableUserListServer struct {
	grpc.ServerStream
}

func (x *authManagerGetDisableUserListServer) Send(m *DisableUserListRsp) error {
	return x.ServerStream.SendMsg(m)
}

var _AuthManager_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dhcpserver.AuthManager",
	HandlerType: (*AuthManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetAuthStatus",
			Handler:    _AuthManager_SetAuthStatus_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SetAuthCfg",
			Handler:       _AuthManager_SetAuthCfg_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "GetAuthCfg",
			Handler:       _AuthManager_GetAuthCfg_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SetDisableUserList",
			Handler:       _AuthManager_SetDisableUserList_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "GetDisableUserList",
			Handler:       _AuthManager_GetDisableUserList_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "dhcpserver.proto",
}

// AddressReconcileManagerClient is the client API for AddressReconcileManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AddressReconcileManagerClient interface {
	SetAddressInspectCfg(ctx context.Context, in *InspectCfgReq, opts ...grpc.CallOption) (*RespResult, error)
}

type addressReconcileManagerClient struct {
	cc *grpc.ClientConn
}

func NewAddressReconcileManagerClient(cc *grpc.ClientConn) AddressReconcileManagerClient {
	return &addressReconcileManagerClient{cc}
}

func (c *addressReconcileManagerClient) SetAddressInspectCfg(ctx context.Context, in *InspectCfgReq, opts ...grpc.CallOption) (*RespResult, error) {
	out := new(RespResult)
	err := c.cc.Invoke(ctx, "/dhcpserver.AddressReconcileManager/SetAddressInspectCfg", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AddressReconcileManagerServer is the server API for AddressReconcileManager service.
type AddressReconcileManagerServer interface {
	SetAddressInspectCfg(context.Context, *InspectCfgReq) (*RespResult, error)
}

// UnimplementedAddressReconcileManagerServer can be embedded to have forward compatible implementations.
type UnimplementedAddressReconcileManagerServer struct {
}

func (*UnimplementedAddressReconcileManagerServer) SetAddressInspectCfg(ctx context.Context, req *InspectCfgReq) (*RespResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAddressInspectCfg not implemented")
}

func RegisterAddressReconcileManagerServer(s *grpc.Server, srv AddressReconcileManagerServer) {
	s.RegisterService(&_AddressReconcileManager_serviceDesc, srv)
}

func _AddressReconcileManager_SetAddressInspectCfg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectCfgReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AddressReconcileManagerServer).SetAddressInspectCfg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dhcpserver.AddressReconcileManager/SetAddressInspectCfg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AddressReconcileManagerServer).SetAddressInspectCfg(ctx, req.(*InspectCfgReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _AddressReconcileManager_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dhcpserver.AddressReconcileManager",
	HandlerType: (*AddressReconcileManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetAddressInspectCfg",
			Handler:    _AddressReconcileManager_SetAddressInspectCfg_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dhcpserver.proto",
}

// DevicePerformanceClient is the client API for DevicePerformance service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DevicePerformanceClient interface {
	//获取设备的性能信息
	GetDeviceInfo(ctx context.Context, in *GetDeviceInfoReq, opts ...grpc.CallOption) (*GetDeviceInfoRsp, error)
}

type devicePerformanceClient struct {
	cc *grpc.ClientConn
}

func NewDevicePerformanceClient(cc *grpc.ClientConn) DevicePerformanceClient {
	return &devicePerformanceClient{cc}
}

func (c *devicePerformanceClient) GetDeviceInfo(ctx context.Context, in *GetDeviceInfoReq, opts ...grpc.CallOption) (*GetDeviceInfoRsp, error) {
	out := new(GetDeviceInfoRsp)
	err := c.cc.Invoke(ctx, "/dhcpserver.DevicePerformance/GetDeviceInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DevicePerformanceServer is the server API for DevicePerformance service.
type DevicePerformanceServer interface {
	//获取设备的性能信息
	GetDeviceInfo(context.Context, *GetDeviceInfoReq) (*GetDeviceInfoRsp, error)
}

// UnimplementedDevicePerformanceServer can be embedded to have forward compatible implementations.
type UnimplementedDevicePerformanceServer struct {
}

func (*UnimplementedDevicePerformanceServer) GetDeviceInfo(ctx context.Context, req *GetDeviceInfoReq) (*GetDeviceInfoRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDeviceInfo not implemented")
}

func RegisterDevicePerformanceServer(s *grpc.Server, srv DevicePerformanceServer) {
	s.RegisterService(&_DevicePerformance_serviceDesc, srv)
}

func _DevicePerformance_GetDeviceInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDeviceInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DevicePerformanceServer).GetDeviceInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dhcpserver.DevicePerformance/GetDeviceInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DevicePerformanceServer).GetDeviceInfo(ctx, req.(*GetDeviceInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _DevicePerformance_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dhcpserver.DevicePerformance",
	HandlerType: (*DevicePerformanceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetDeviceInfo",
			Handler:    _DevicePerformance_GetDeviceInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dhcpserver.proto",
}

// FingerprintManagerClient is the client API for FingerprintManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type FingerprintManagerClient interface {
	//指纹信息下发
	SetFingerprint(ctx context.Context, in *FingerprintReq, opts ...grpc.CallOption) (*RespResult, error)
	GetFingerprint(ctx context.Context, in *ReqStatus, opts ...grpc.CallOption) (*FingerprintRsp, error)
}

type fingerprintManagerClient struct {
	cc *grpc.ClientConn
}

func NewFingerprintManagerClient(cc *grpc.ClientConn) FingerprintManagerClient {
	return &fingerprintManagerClient{cc}
}

func (c *fingerprintManagerClient) SetFingerprint(ctx context.Context, in *FingerprintReq, opts ...grpc.CallOption) (*RespResult, error) {
	out := new(RespResult)
	err := c.cc.Invoke(ctx, "/dhcpserver.FingerprintManager/SetFingerprint", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fingerprintManagerClient) GetFingerprint(ctx context.Context, in *ReqStatus, opts ...grpc.CallOption) (*FingerprintRsp, error) {
	out := new(FingerprintRsp)
	err := c.cc.Invoke(ctx, "/dhcpserver.FingerprintManager/GetFingerprint", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FingerprintManagerServer is the server API for FingerprintManager service.
type FingerprintManagerServer interface {
	//指纹信息下发
	SetFingerprint(context.Context, *FingerprintReq) (*RespResult, error)
	GetFingerprint(context.Context, *ReqStatus) (*FingerprintRsp, error)
}

// UnimplementedFingerprintManagerServer can be embedded to have forward compatible implementations.
type UnimplementedFingerprintManagerServer struct {
}

func (*UnimplementedFingerprintManagerServer) SetFingerprint(ctx context.Context, req *FingerprintReq) (*RespResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetFingerprint not implemented")
}
func (*UnimplementedFingerprintManagerServer) GetFingerprint(ctx context.Context, req *ReqStatus) (*FingerprintRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFingerprint not implemented")
}

func RegisterFingerprintManagerServer(s *grpc.Server, srv FingerprintManagerServer) {
	s.RegisterService(&_FingerprintManager_serviceDesc, srv)
}

func _FingerprintManager_SetFingerprint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FingerprintReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FingerprintManagerServer).SetFingerprint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dhcpserver.FingerprintManager/SetFingerprint",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FingerprintManagerServer).SetFingerprint(ctx, req.(*FingerprintReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FingerprintManager_GetFingerprint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FingerprintManagerServer).GetFingerprint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dhcpserver.FingerprintManager/GetFingerprint",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FingerprintManagerServer).GetFingerprint(ctx, req.(*ReqStatus))
	}
	return interceptor(ctx, in, info, handler)
}

var _FingerprintManager_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dhcpserver.FingerprintManager",
	HandlerType: (*FingerprintManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetFingerprint",
			Handler:    _FingerprintManager_SetFingerprint_Handler,
		},
		{
			MethodName: "GetFingerprint",
			Handler:    _FingerprintManager_GetFingerprint_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dhcpserver.proto",
}

// OptionsManagerClient is the client API for OptionsManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type OptionsManagerClient interface {
	//options 配置
	SetOptions(ctx context.Context, in *OptionsReq, opts ...grpc.CallOption) (*RespResult, error)
	GetOptions(ctx context.Context, in *ReqStatus, opts ...grpc.CallOption) (*OptionsRsp, error)
}

type optionsManagerClient struct {
	cc *grpc.ClientConn
}

func NewOptionsManagerClient(cc *grpc.ClientConn) OptionsManagerClient {
	return &optionsManagerClient{cc}
}

func (c *optionsManagerClient) SetOptions(ctx context.Context, in *OptionsReq, opts ...grpc.CallOption) (*RespResult, error) {
	out := new(RespResult)
	err := c.cc.Invoke(ctx, "/dhcpserver.OptionsManager/SetOptions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *optionsManagerClient) GetOptions(ctx context.Context, in *ReqStatus, opts ...grpc.CallOption) (*OptionsRsp, error) {
	out := new(OptionsRsp)
	err := c.cc.Invoke(ctx, "/dhcpserver.OptionsManager/GetOptions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OptionsManagerServer is the server API for OptionsManager service.
type OptionsManagerServer interface {
	//options 配置
	SetOptions(context.Context, *OptionsReq) (*RespResult, error)
	GetOptions(context.Context, *ReqStatus) (*OptionsRsp, error)
}

// UnimplementedOptionsManagerServer can be embedded to have forward compatible implementations.
type UnimplementedOptionsManagerServer struct {
}

func (*UnimplementedOptionsManagerServer) SetOptions(ctx context.Context, req *OptionsReq) (*RespResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetOptions not implemented")
}
func (*UnimplementedOptionsManagerServer) GetOptions(ctx context.Context, req *ReqStatus) (*OptionsRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOptions not implemented")
}

func RegisterOptionsManagerServer(s *grpc.Server, srv OptionsManagerServer) {
	s.RegisterService(&_OptionsManager_serviceDesc, srv)
}

func _OptionsManager_SetOptions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OptionsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OptionsManagerServer).SetOptions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dhcpserver.OptionsManager/SetOptions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OptionsManagerServer).SetOptions(ctx, req.(*OptionsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _OptionsManager_GetOptions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OptionsManagerServer).GetOptions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dhcpserver.OptionsManager/GetOptions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OptionsManagerServer).GetOptions(ctx, req.(*ReqStatus))
	}
	return interceptor(ctx, in, info, handler)
}

var _OptionsManager_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dhcpserver.OptionsManager",
	HandlerType: (*OptionsManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetOptions",
			Handler:    _OptionsManager_SetOptions_Handler,
		},
		{
			MethodName: "GetOptions",
			Handler:    _OptionsManager_GetOptions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dhcpserver.proto",
}

func (m *ReqStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReqStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Index != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SubnetInfos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubnetInfos) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubnetInfos) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Ev) > 0 {
		for iNdEx := len(m.Ev) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ev[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDhcpserver(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.OperateType != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.OperateType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SubnetInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubnetInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubnetInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.V6Sub != nil {
		{
			size, err := m.V6Sub.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDhcpserver(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.V4Sub != nil {
		{
			size, err := m.V4Sub.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDhcpserver(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.SubnetValid != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.SubnetValid))
		i--
		dAtA[i] = 0x30
	}
	if m.BwType != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.BwType))
		i--
		dAtA[i] = 0x28
	}
	if m.Type != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x20
	}
	if m.VlanId != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.VlanId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDhcpserver(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Index != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NetworkSegmentInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkSegmentInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkSegmentInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Net) > 0 {
		i -= len(m.Net)
		copy(dAtA[i:], m.Net)
		i = encodeVarintDhcpserver(dAtA, i, uint64(len(m.Net)))
		i--
		dAtA[i] = 0x12
	}
	if m.Index != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *V4SubInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *V4SubInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *V4SubInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Pool) > 0 {
		for iNdEx := len(m.Pool) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pool[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDhcpserver(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.NetSegment) > 0 {
		for iNdEx := len(m.NetSegment) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NetSegment[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDhcpserver(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *V6SubInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *V6SubInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *V6SubInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PdInfo != nil {
		{
			size, err := m.PdInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDhcpserver(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Pool) > 0 {
		for iNdEx := len(m.Pool) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pool[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDhcpserver(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.NetSegment) > 0 {
		for iNdEx := len(m.NetSegment) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NetSegment[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDhcpserver(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PoolInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PoolInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PoolInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.End) > 0 {
		i -= len(m.End)
		copy(dAtA[i:], m.End)
		i = encodeVarintDhcpserver(dAtA, i, uint64(len(m.End)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Beg) > 0 {
		i -= len(m.Beg)
		copy(dAtA[i:], m.Beg)
		i = encodeVarintDhcpserver(dAtA, i, uint64(len(m.Beg)))
		i--
		dAtA[i] = 0x22
	}
	if m.Index != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PDPrefixInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PDPrefixInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PDPrefixInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EndPrefix) > 0 {
		i -= len(m.EndPrefix)
		copy(dAtA[i:], m.EndPrefix)
		i = encodeVarintDhcpserver(dAtA, i, uint64(len(m.EndPrefix)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StartPrefix) > 0 {
		i -= len(m.StartPrefix)
		copy(dAtA[i:], m.StartPrefix)
		i = encodeVarintDhcpserver(dAtA, i, uint64(len(m.StartPrefix)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IpStaticInfos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpStaticInfos) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpStaticInfos) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Ev) > 0 {
		for iNdEx := len(m.Ev) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ev[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDhcpserver(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.OperateType != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.OperateType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IpStaticInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpStaticInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpStaticInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.V6Ip) > 0 {
		i -= len(m.V6Ip)
		copy(dAtA[i:], m.V6Ip)
		i = encodeVarintDhcpserver(dAtA, i, uint64(len(m.V6Ip)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.V4Ip) > 0 {
		i -= len(m.V4Ip)
		copy(dAtA[i:], m.V4Ip)
		i = encodeVarintDhcpserver(dAtA, i, uint64(len(m.V4Ip)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Duid) > 0 {
		i -= len(m.Duid)
		copy(dAtA[i:], m.Duid)
		i = encodeVarintDhcpserver(dAtA, i, uint64(len(m.Duid)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Mac) > 0 {
		i -= len(m.Mac)
		copy(dAtA[i:], m.Mac)
		i = encodeVarintDhcpserver(dAtA, i, uint64(len(m.Mac)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SubnetId != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.SubnetId))
		i--
		dAtA[i] = 0x10
	}
	if m.Index != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RespResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RespResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RespResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintDhcpserver(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if m.ResultCode != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.ResultCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BlackAndWhiteListInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlackAndWhiteListInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlackAndWhiteListInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Notes) > 0 {
		i -= len(m.Notes)
		copy(dAtA[i:], m.Notes)
		i = encodeVarintDhcpserver(dAtA, i, uint64(len(m.Notes)))
		i--
		dAtA[i] = 0x32
	}
	if m.SubnetId != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.SubnetId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.UserName) > 0 {
		i -= len(m.UserName)
		copy(dAtA[i:], m.UserName)
		i = encodeVarintDhcpserver(dAtA, i, uint64(len(m.UserName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MacAddress) > 0 {
		i -= len(m.MacAddress)
		copy(dAtA[i:], m.MacAddress)
		i = encodeVarintDhcpserver(dAtA, i, uint64(len(m.MacAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ListType != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.ListType))
		i--
		dAtA[i] = 0x10
	}
	if m.Index != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BlackAndWhiteListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlackAndWhiteListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlackAndWhiteListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ListInfo) > 0 {
		for iNdEx := len(m.ListInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ListInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDhcpserver(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.OperType != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.OperType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetBWListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBWListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetBWListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ListType != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.ListType))
		i--
		dAtA[i] = 0x10
	}
	if m.Index != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetBWListResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBWListResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetBWListResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RespList) > 0 {
		for iNdEx := len(m.RespList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RespList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDhcpserver(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *StatusBWListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatusBWListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatusBWListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if m.ListType != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.ListType))
		i--
		dAtA[i] = 0x10
	}
	if m.Index != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ServerCfgInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServerCfgInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServerCfgInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SeparateDigit != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.SeparateDigit))
		i--
		dAtA[i] = 0x58
	}
	if m.AutoUpdateLeaseTime != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.AutoUpdateLeaseTime))
		i--
		dAtA[i] = 0x50
	}
	if m.MaxLoadBalancingTime != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.MaxLoadBalancingTime))
		i--
		dAtA[i] = 0x48
	}
	if m.MaxUpdateTimes != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.MaxUpdateTimes))
		i--
		dAtA[i] = 0x40
	}
	if m.MonitorTime != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.MonitorTime))
		i--
		dAtA[i] = 0x38
	}
	if m.PeerPort != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.PeerPort))
		i--
		dAtA[i] = 0x30
	}
	if len(m.PeerAddress) > 0 {
		i -= len(m.PeerAddress)
		copy(dAtA[i:], m.PeerAddress)
		i = encodeVarintDhcpserver(dAtA, i, uint64(len(m.PeerAddress)))
		i--
		dAtA[i] = 0x2a
	}
	if m.LocalPort != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.LocalPort))
		i--
		dAtA[i] = 0x20
	}
	if len(m.LocalAddress) > 0 {
		i -= len(m.LocalAddress)
		copy(dAtA[i:], m.LocalAddress)
		i = encodeVarintDhcpserver(dAtA, i, uint64(len(m.LocalAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ServerType != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.ServerType))
		i--
		dAtA[i] = 0x10
	}
	if m.Index != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetServerCfgReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetServerCfgReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetServerCfgReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ServerConfig) > 0 {
		for iNdEx := len(m.ServerConfig) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ServerConfig[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDhcpserver(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.OperType != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.OperType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetServerCfgReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetServerCfgReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetServerCfgReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ServerType != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.ServerType))
		i--
		dAtA[i] = 0x10
	}
	if m.Index != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetServerCfgResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetServerCfgResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetServerCfgResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RespServer) > 0 {
		for iNdEx := len(m.RespServer) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RespServer[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDhcpserver(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AuthCfgInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthCfgInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthCfgInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Notes) > 0 {
		i -= len(m.Notes)
		copy(dAtA[i:], m.Notes)
		i = encodeVarintDhcpserver(dAtA, i, uint64(len(m.Notes)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ExpireDate) > 0 {
		i -= len(m.ExpireDate)
		copy(dAtA[i:], m.ExpireDate)
		i = encodeVarintDhcpserver(dAtA, i, uint64(len(m.ExpireDate)))
		i--
		dAtA[i] = 0x32
	}
	if m.ExpireTime != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.ExpireTime))
		i--
		dAtA[i] = 0x28
	}
	if len(m.UserName) > 0 {
		i -= len(m.UserName)
		copy(dAtA[i:], m.UserName)
		i = encodeVarintDhcpserver(dAtA, i, uint64(len(m.UserName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MacAddress) > 0 {
		i -= len(m.MacAddress)
		copy(dAtA[i:], m.MacAddress)
		i = encodeVarintDhcpserver(dAtA, i, uint64(len(m.MacAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Index != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AuthCfgReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthCfgReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthCfgReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AuthConfig) > 0 {
		for iNdEx := len(m.AuthConfig) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AuthConfig[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDhcpserver(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.OperType != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.OperType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetAuthCfgReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAuthCfgReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAuthCfgReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Type != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Index != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetAuthCfgResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAuthCfgResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAuthCfgResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RespAuth) > 0 {
		for iNdEx := len(m.RespAuth) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RespAuth[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDhcpserver(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *StatusAuthReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatusAuthReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatusAuthReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Index != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DisableUserListInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DisableUserListInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DisableUserListInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UserName) > 0 {
		i -= len(m.UserName)
		copy(dAtA[i:], m.UserName)
		i = encodeVarintDhcpserver(dAtA, i, uint64(len(m.UserName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MacAddress) > 0 {
		i -= len(m.MacAddress)
		copy(dAtA[i:], m.MacAddress)
		i = encodeVarintDhcpserver(dAtA, i, uint64(len(m.MacAddress)))
		i--
		dAtA[i] = 0x12
	}
	if m.Index != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DisableUserListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DisableUserListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DisableUserListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CfgInfo) > 0 {
		for iNdEx := len(m.CfgInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CfgInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDhcpserver(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.OperType != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.OperType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DisableUserListRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DisableUserListRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DisableUserListRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CfgInfo) > 0 {
		for iNdEx := len(m.CfgInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CfgInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDhcpserver(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *InspectCfgReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectCfgReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InspectCfgReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.InspectCycle != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.InspectCycle))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetDeviceInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetDeviceInfoReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetDeviceInfoReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IpAddr) > 0 {
		for iNdEx := len(m.IpAddr) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IpAddr[iNdEx])
			copy(dAtA[i:], m.IpAddr[iNdEx])
			i = encodeVarintDhcpserver(dAtA, i, uint64(len(m.IpAddr[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeviceStatInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceStatInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceStatInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DiskUsageRate != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DiskUsageRate))))
		i--
		dAtA[i] = 0x25
	}
	if m.MemoryUsageRate != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.MemoryUsageRate))))
		i--
		dAtA[i] = 0x1d
	}
	if m.CpuUsageRate != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.CpuUsageRate))))
		i--
		dAtA[i] = 0x15
	}
	if len(m.IpAddr) > 0 {
		i -= len(m.IpAddr)
		copy(dAtA[i:], m.IpAddr)
		i = encodeVarintDhcpserver(dAtA, i, uint64(len(m.IpAddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetDeviceInfoRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetDeviceInfoRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetDeviceInfoRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.StatInfo) > 0 {
		for iNdEx := len(m.StatInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StatInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDhcpserver(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FingerprintInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FingerprintInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FingerprintInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SystemName) > 0 {
		i -= len(m.SystemName)
		copy(dAtA[i:], m.SystemName)
		i = encodeVarintDhcpserver(dAtA, i, uint64(len(m.SystemName)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Supplier) > 0 {
		i -= len(m.Supplier)
		copy(dAtA[i:], m.Supplier)
		i = encodeVarintDhcpserver(dAtA, i, uint64(len(m.Supplier)))
		i--
		dAtA[i] = 0x42
	}
	if m.MessageType != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.MessageType))
		i--
		dAtA[i] = 0x38
	}
	if m.ProtocolType != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.ProtocolType))
		i--
		dAtA[i] = 0x30
	}
	if len(m.OptionValue) > 0 {
		i -= len(m.OptionValue)
		copy(dAtA[i:], m.OptionValue)
		i = encodeVarintDhcpserver(dAtA, i, uint64(len(m.OptionValue)))
		i--
		dAtA[i] = 0x2a
	}
	if m.OptionId != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.OptionId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Options) > 0 {
		i -= len(m.Options)
		copy(dAtA[i:], m.Options)
		i = encodeVarintDhcpserver(dAtA, i, uint64(len(m.Options)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Ttl != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.Ttl))
		i--
		dAtA[i] = 0x10
	}
	if m.Index != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FingerprintReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FingerprintReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FingerprintReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CfgInfo) > 0 {
		for iNdEx := len(m.CfgInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CfgInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDhcpserver(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.OperType != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.OperType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FingerprintRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FingerprintRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FingerprintRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CfgInfo) > 0 {
		for iNdEx := len(m.CfgInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CfgInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDhcpserver(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OptionsInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OptionsInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OptionsInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SubnetId != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.SubnetId))
		i--
		dAtA[i] = 0x30
	}
	if m.ProtocolType != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.ProtocolType))
		i--
		dAtA[i] = 0x28
	}
	if len(m.OptionValue) > 0 {
		i -= len(m.OptionValue)
		copy(dAtA[i:], m.OptionValue)
		i = encodeVarintDhcpserver(dAtA, i, uint64(len(m.OptionValue)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OptionName) > 0 {
		i -= len(m.OptionName)
		copy(dAtA[i:], m.OptionName)
		i = encodeVarintDhcpserver(dAtA, i, uint64(len(m.OptionName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.OptionId != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.OptionId))
		i--
		dAtA[i] = 0x10
	}
	if m.Index != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OptionsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OptionsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OptionsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Info) > 0 {
		for iNdEx := len(m.Info) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Info[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDhcpserver(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.OperType != 0 {
		i = encodeVarintDhcpserver(dAtA, i, uint64(m.OperType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OptionsRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OptionsRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OptionsRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Info) > 0 {
		for iNdEx := len(m.Info) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Info[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDhcpserver(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintDhcpserver(dAtA []byte, offset int, v uint64) int {
	offset -= sovDhcpserver(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ReqStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovDhcpserver(uint64(m.Index))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubnetInfos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OperateType != 0 {
		n += 1 + sovDhcpserver(uint64(m.OperateType))
	}
	if len(m.Ev) > 0 {
		for _, e := range m.Ev {
			l = e.Size()
			n += 1 + l + sovDhcpserver(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubnetInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovDhcpserver(uint64(m.Index))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDhcpserver(uint64(l))
	}
	if m.VlanId != 0 {
		n += 1 + sovDhcpserver(uint64(m.VlanId))
	}
	if m.Type != 0 {
		n += 1 + sovDhcpserver(uint64(m.Type))
	}
	if m.BwType != 0 {
		n += 1 + sovDhcpserver(uint64(m.BwType))
	}
	if m.SubnetValid != 0 {
		n += 1 + sovDhcpserver(uint64(m.SubnetValid))
	}
	if m.V4Sub != nil {
		l = m.V4Sub.Size()
		n += 1 + l + sovDhcpserver(uint64(l))
	}
	if m.V6Sub != nil {
		l = m.V6Sub.Size()
		n += 1 + l + sovDhcpserver(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NetworkSegmentInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovDhcpserver(uint64(m.Index))
	}
	l = len(m.Net)
	if l > 0 {
		n += 1 + l + sovDhcpserver(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *V4SubInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.NetSegment) > 0 {
		for _, e := range m.NetSegment {
			l = e.Size()
			n += 1 + l + sovDhcpserver(uint64(l))
		}
	}
	if len(m.Pool) > 0 {
		for _, e := range m.Pool {
			l = e.Size()
			n += 1 + l + sovDhcpserver(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *V6SubInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.NetSegment) > 0 {
		for _, e := range m.NetSegment {
			l = e.Size()
			n += 1 + l + sovDhcpserver(uint64(l))
		}
	}
	if len(m.Pool) > 0 {
		for _, e := range m.Pool {
			l = e.Size()
			n += 1 + l + sovDhcpserver(uint64(l))
		}
	}
	if m.PdInfo != nil {
		l = m.PdInfo.Size()
		n += 1 + l + sovDhcpserver(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PoolInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovDhcpserver(uint64(m.Index))
	}
	l = len(m.Beg)
	if l > 0 {
		n += 1 + l + sovDhcpserver(uint64(l))
	}
	l = len(m.End)
	if l > 0 {
		n += 1 + l + sovDhcpserver(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PDPrefixInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StartPrefix)
	if l > 0 {
		n += 1 + l + sovDhcpserver(uint64(l))
	}
	l = len(m.EndPrefix)
	if l > 0 {
		n += 1 + l + sovDhcpserver(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IpStaticInfos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OperateType != 0 {
		n += 1 + sovDhcpserver(uint64(m.OperateType))
	}
	if len(m.Ev) > 0 {
		for _, e := range m.Ev {
			l = e.Size()
			n += 1 + l + sovDhcpserver(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IpStaticInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovDhcpserver(uint64(m.Index))
	}
	if m.SubnetId != 0 {
		n += 1 + sovDhcpserver(uint64(m.SubnetId))
	}
	l = len(m.Mac)
	if l > 0 {
		n += 1 + l + sovDhcpserver(uint64(l))
	}
	l = len(m.Duid)
	if l > 0 {
		n += 1 + l + sovDhcpserver(uint64(l))
	}
	l = len(m.V4Ip)
	if l > 0 {
		n += 1 + l + sovDhcpserver(uint64(l))
	}
	l = len(m.V6Ip)
	if l > 0 {
		n += 1 + l + sovDhcpserver(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RespResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResultCode != 0 {
		n += 1 + sovDhcpserver(uint64(m.ResultCode))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovDhcpserver(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlackAndWhiteListInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovDhcpserver(uint64(m.Index))
	}
	if m.ListType != 0 {
		n += 1 + sovDhcpserver(uint64(m.ListType))
	}
	l = len(m.MacAddress)
	if l > 0 {
		n += 1 + l + sovDhcpserver(uint64(l))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovDhcpserver(uint64(l))
	}
	if m.SubnetId != 0 {
		n += 1 + sovDhcpserver(uint64(m.SubnetId))
	}
	l = len(m.Notes)
	if l > 0 {
		n += 1 + l + sovDhcpserver(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovDhcpserver(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlackAndWhiteListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OperType != 0 {
		n += 1 + sovDhcpserver(uint64(m.OperType))
	}
	if len(m.ListInfo) > 0 {
		for _, e := range m.ListInfo {
			l = e.Size()
			n += 1 + l + sovDhcpserver(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetBWListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovDhcpserver(uint64(m.Index))
	}
	if m.ListType != 0 {
		n += 1 + sovDhcpserver(uint64(m.ListType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetBWListResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RespList) > 0 {
		for _, e := range m.RespList {
			l = e.Size()
			n += 1 + l + sovDhcpserver(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StatusBWListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovDhcpserver(uint64(m.Index))
	}
	if m.ListType != 0 {
		n += 1 + sovDhcpserver(uint64(m.ListType))
	}
	if m.Status != 0 {
		n += 1 + sovDhcpserver(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServerCfgInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovDhcpserver(uint64(m.Index))
	}
	if m.ServerType != 0 {
		n += 1 + sovDhcpserver(uint64(m.ServerType))
	}
	l = len(m.LocalAddress)
	if l > 0 {
		n += 1 + l + sovDhcpserver(uint64(l))
	}
	if m.LocalPort != 0 {
		n += 1 + sovDhcpserver(uint64(m.LocalPort))
	}
	l = len(m.PeerAddress)
	if l > 0 {
		n += 1 + l + sovDhcpserver(uint64(l))
	}
	if m.PeerPort != 0 {
		n += 1 + sovDhcpserver(uint64(m.PeerPort))
	}
	if m.MonitorTime != 0 {
		n += 1 + sovDhcpserver(uint64(m.MonitorTime))
	}
	if m.MaxUpdateTimes != 0 {
		n += 1 + sovDhcpserver(uint64(m.MaxUpdateTimes))
	}
	if m.MaxLoadBalancingTime != 0 {
		n += 1 + sovDhcpserver(uint64(m.MaxLoadBalancingTime))
	}
	if m.AutoUpdateLeaseTime != 0 {
		n += 1 + sovDhcpserver(uint64(m.AutoUpdateLeaseTime))
	}
	if m.SeparateDigit != 0 {
		n += 1 + sovDhcpserver(uint64(m.SeparateDigit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetServerCfgReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OperType != 0 {
		n += 1 + sovDhcpserver(uint64(m.OperType))
	}
	if len(m.ServerConfig) > 0 {
		for _, e := range m.ServerConfig {
			l = e.Size()
			n += 1 + l + sovDhcpserver(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetServerCfgReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovDhcpserver(uint64(m.Index))
	}
	if m.ServerType != 0 {
		n += 1 + sovDhcpserver(uint64(m.ServerType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetServerCfgResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RespServer) > 0 {
		for _, e := range m.RespServer {
			l = e.Size()
			n += 1 + l + sovDhcpserver(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuthCfgInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovDhcpserver(uint64(m.Index))
	}
	if m.Type != 0 {
		n += 1 + sovDhcpserver(uint64(m.Type))
	}
	l = len(m.MacAddress)
	if l > 0 {
		n += 1 + l + sovDhcpserver(uint64(l))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovDhcpserver(uint64(l))
	}
	if m.ExpireTime != 0 {
		n += 1 + sovDhcpserver(uint64(m.ExpireTime))
	}
	l = len(m.ExpireDate)
	if l > 0 {
		n += 1 + l + sovDhcpserver(uint64(l))
	}
	l = len(m.Notes)
	if l > 0 {
		n += 1 + l + sovDhcpserver(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovDhcpserver(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuthCfgReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OperType != 0 {
		n += 1 + sovDhcpserver(uint64(m.OperType))
	}
	if len(m.AuthConfig) > 0 {
		for _, e := range m.AuthConfig {
			l = e.Size()
			n += 1 + l + sovDhcpserver(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetAuthCfgReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovDhcpserver(uint64(m.Index))
	}
	if m.Type != 0 {
		n += 1 + sovDhcpserver(uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetAuthCfgResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RespAuth) > 0 {
		for _, e := range m.RespAuth {
			l = e.Size()
			n += 1 + l + sovDhcpserver(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StatusAuthReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovDhcpserver(uint64(m.Index))
	}
	if m.Type != 0 {
		n += 1 + sovDhcpserver(uint64(m.Type))
	}
	if m.Status != 0 {
		n += 1 + sovDhcpserver(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DisableUserListInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovDhcpserver(uint64(m.Index))
	}
	l = len(m.MacAddress)
	if l > 0 {
		n += 1 + l + sovDhcpserver(uint64(l))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovDhcpserver(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DisableUserListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OperType != 0 {
		n += 1 + sovDhcpserver(uint64(m.OperType))
	}
	if len(m.CfgInfo) > 0 {
		for _, e := range m.CfgInfo {
			l = e.Size()
			n += 1 + l + sovDhcpserver(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DisableUserListRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CfgInfo) > 0 {
		for _, e := range m.CfgInfo {
			l = e.Size()
			n += 1 + l + sovDhcpserver(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InspectCfgReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InspectCycle != 0 {
		n += 1 + sovDhcpserver(uint64(m.InspectCycle))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetDeviceInfoReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.IpAddr) > 0 {
		for _, s := range m.IpAddr {
			l = len(s)
			n += 1 + l + sovDhcpserver(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeviceStatInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.IpAddr)
	if l > 0 {
		n += 1 + l + sovDhcpserver(uint64(l))
	}
	if m.CpuUsageRate != 0 {
		n += 5
	}
	if m.MemoryUsageRate != 0 {
		n += 5
	}
	if m.DiskUsageRate != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetDeviceInfoRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.StatInfo) > 0 {
		for _, e := range m.StatInfo {
			l = e.Size()
			n += 1 + l + sovDhcpserver(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FingerprintInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovDhcpserver(uint64(m.Index))
	}
	if m.Ttl != 0 {
		n += 1 + sovDhcpserver(uint64(m.Ttl))
	}
	l = len(m.Options)
	if l > 0 {
		n += 1 + l + sovDhcpserver(uint64(l))
	}
	if m.OptionId != 0 {
		n += 1 + sovDhcpserver(uint64(m.OptionId))
	}
	l = len(m.OptionValue)
	if l > 0 {
		n += 1 + l + sovDhcpserver(uint64(l))
	}
	if m.ProtocolType != 0 {
		n += 1 + sovDhcpserver(uint64(m.ProtocolType))
	}
	if m.MessageType != 0 {
		n += 1 + sovDhcpserver(uint64(m.MessageType))
	}
	l = len(m.Supplier)
	if l > 0 {
		n += 1 + l + sovDhcpserver(uint64(l))
	}
	l = len(m.SystemName)
	if l > 0 {
		n += 1 + l + sovDhcpserver(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FingerprintReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OperType != 0 {
		n += 1 + sovDhcpserver(uint64(m.OperType))
	}
	if len(m.CfgInfo) > 0 {
		for _, e := range m.CfgInfo {
			l = e.Size()
			n += 1 + l + sovDhcpserver(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FingerprintRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CfgInfo) > 0 {
		for _, e := range m.CfgInfo {
			l = e.Size()
			n += 1 + l + sovDhcpserver(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OptionsInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovDhcpserver(uint64(m.Index))
	}
	if m.OptionId != 0 {
		n += 1 + sovDhcpserver(uint64(m.OptionId))
	}
	l = len(m.OptionName)
	if l > 0 {
		n += 1 + l + sovDhcpserver(uint64(l))
	}
	l = len(m.OptionValue)
	if l > 0 {
		n += 1 + l + sovDhcpserver(uint64(l))
	}
	if m.ProtocolType != 0 {
		n += 1 + sovDhcpserver(uint64(m.ProtocolType))
	}
	if m.SubnetId != 0 {
		n += 1 + sovDhcpserver(uint64(m.SubnetId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OptionsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OperType != 0 {
		n += 1 + sovDhcpserver(uint64(m.OperType))
	}
	if len(m.Info) > 0 {
		for _, e := range m.Info {
			l = e.Size()
			n += 1 + l + sovDhcpserver(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OptionsRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Info) > 0 {
		for _, e := range m.Info {
			l = e.Size()
			n += 1 + l + sovDhcpserver(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovDhcpserver(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDhcpserver(x uint64) (n int) {
	return sovDhcpserver(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ReqStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDhcpserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubnetInfos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubnetInfos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubnetInfos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperateType", wireType)
			}
			m.OperateType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperateType |= OperationType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ev", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ev = append(m.Ev, &SubnetInfo{})
			if err := m.Ev[len(m.Ev)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDhcpserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubnetInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubnetInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubnetInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VlanId", wireType)
			}
			m.VlanId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VlanId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= SubnetType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BwType", wireType)
			}
			m.BwType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BwType |= ListType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetValid", wireType)
			}
			m.SubnetValid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubnetValid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V4Sub", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.V4Sub == nil {
				m.V4Sub = &V4SubInfo{}
			}
			if err := m.V4Sub.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V6Sub", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.V6Sub == nil {
				m.V6Sub = &V6SubInfo{}
			}
			if err := m.V6Sub.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDhcpserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkSegmentInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkSegmentInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkSegmentInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Net", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Net = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDhcpserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *V4SubInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: V4SubInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: V4SubInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetSegment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetSegment = append(m.NetSegment, &NetworkSegmentInfo{})
			if err := m.NetSegment[len(m.NetSegment)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pool = append(m.Pool, &PoolInfo{})
			if err := m.Pool[len(m.Pool)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDhcpserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *V6SubInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: V6SubInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: V6SubInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetSegment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetSegment = append(m.NetSegment, &NetworkSegmentInfo{})
			if err := m.NetSegment[len(m.NetSegment)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pool = append(m.Pool, &PoolInfo{})
			if err := m.Pool[len(m.Pool)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PdInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PdInfo == nil {
				m.PdInfo = &PDPrefixInfo{}
			}
			if err := m.PdInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDhcpserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PoolInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PoolInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PoolInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Beg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Beg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.End = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDhcpserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PDPrefixInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PDPrefixInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PDPrefixInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDhcpserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpStaticInfos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpStaticInfos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpStaticInfos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperateType", wireType)
			}
			m.OperateType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperateType |= OperationType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ev", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ev = append(m.Ev, &IpStaticInfo{})
			if err := m.Ev[len(m.Ev)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDhcpserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpStaticInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpStaticInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpStaticInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetId", wireType)
			}
			m.SubnetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubnetId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mac", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mac = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Duid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V4Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.V4Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V6Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.V6Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDhcpserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RespResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RespResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RespResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultCode", wireType)
			}
			m.ResultCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResultCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDhcpserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlackAndWhiteListInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlackAndWhiteListInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlackAndWhiteListInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListType", wireType)
			}
			m.ListType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ListType |= ListType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetId", wireType)
			}
			m.SubnetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubnetId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDhcpserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlackAndWhiteListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlackAndWhiteListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlackAndWhiteListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperType", wireType)
			}
			m.OperType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperType |= OperationType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ListInfo = append(m.ListInfo, &BlackAndWhiteListInfo{})
			if err := m.ListInfo[len(m.ListInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDhcpserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBWListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBWListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBWListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListType", wireType)
			}
			m.ListType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ListType |= ListType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDhcpserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBWListResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBWListResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBWListResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RespList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RespList = append(m.RespList, &BlackAndWhiteListInfo{})
			if err := m.RespList[len(m.RespList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDhcpserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatusBWListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatusBWListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatusBWListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListType", wireType)
			}
			m.ListType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ListType |= ListType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDhcpserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServerCfgInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerCfgInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerCfgInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerType", wireType)
			}
			m.ServerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerType |= ServerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalPort", wireType)
			}
			m.LocalPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerPort", wireType)
			}
			m.PeerPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonitorTime", wireType)
			}
			m.MonitorTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MonitorTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxUpdateTimes", wireType)
			}
			m.MaxUpdateTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxUpdateTimes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLoadBalancingTime", wireType)
			}
			m.MaxLoadBalancingTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLoadBalancingTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoUpdateLeaseTime", wireType)
			}
			m.AutoUpdateLeaseTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoUpdateLeaseTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeparateDigit", wireType)
			}
			m.SeparateDigit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeparateDigit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDhcpserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetServerCfgReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetServerCfgReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetServerCfgReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperType", wireType)
			}
			m.OperType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperType |= OperationType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerConfig = append(m.ServerConfig, &ServerCfgInfo{})
			if err := m.ServerConfig[len(m.ServerConfig)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDhcpserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetServerCfgReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetServerCfgReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetServerCfgReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerType", wireType)
			}
			m.ServerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerType |= ServerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDhcpserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetServerCfgResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetServerCfgResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetServerCfgResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RespServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RespServer = append(m.RespServer, &ServerCfgInfo{})
			if err := m.RespServer[len(m.RespServer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDhcpserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthCfgInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthCfgInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthCfgInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= AuthType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpireTime", wireType)
			}
			m.ExpireTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpireTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpireDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpireDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDhcpserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthCfgReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthCfgReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthCfgReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperType", wireType)
			}
			m.OperType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperType |= OperationType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthConfig = append(m.AuthConfig, &AuthCfgInfo{})
			if err := m.AuthConfig[len(m.AuthConfig)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDhcpserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAuthCfgReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAuthCfgReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAuthCfgReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= AuthType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDhcpserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAuthCfgResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAuthCfgResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAuthCfgResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RespAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RespAuth = append(m.RespAuth, &AuthCfgInfo{})
			if err := m.RespAuth[len(m.RespAuth)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDhcpserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatusAuthReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatusAuthReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatusAuthReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= AuthType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDhcpserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DisableUserListInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DisableUserListInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DisableUserListInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDhcpserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DisableUserListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DisableUserListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DisableUserListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperType", wireType)
			}
			m.OperType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperType |= OperationType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CfgInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CfgInfo = append(m.CfgInfo, &DisableUserListInfo{})
			if err := m.CfgInfo[len(m.CfgInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDhcpserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DisableUserListRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DisableUserListRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DisableUserListRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CfgInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CfgInfo = append(m.CfgInfo, &DisableUserListInfo{})
			if err := m.CfgInfo[len(m.CfgInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDhcpserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectCfgReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectCfgReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectCfgReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InspectCycle", wireType)
			}
			m.InspectCycle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InspectCycle |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDhcpserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetDeviceInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetDeviceInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetDeviceInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddr = append(m.IpAddr, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDhcpserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceStatInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceStatInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceStatInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuUsageRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.CpuUsageRate = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryUsageRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.MemoryUsageRate = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskUsageRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DiskUsageRate = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipDhcpserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetDeviceInfoRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetDeviceInfoRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetDeviceInfoRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatInfo = append(m.StatInfo, &DeviceStatInfo{})
			if err := m.StatInfo[len(m.StatInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDhcpserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FingerprintInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FingerprintInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FingerprintInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			m.Ttl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ttl |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Options = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionId", wireType)
			}
			m.OptionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolType", wireType)
			}
			m.ProtocolType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtocolType |= ProtocolType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageType", wireType)
			}
			m.MessageType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Supplier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Supplier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SystemName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDhcpserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FingerprintReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FingerprintReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FingerprintReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperType", wireType)
			}
			m.OperType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperType |= OperationType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CfgInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CfgInfo = append(m.CfgInfo, &FingerprintInfo{})
			if err := m.CfgInfo[len(m.CfgInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDhcpserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FingerprintRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FingerprintRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FingerprintRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CfgInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CfgInfo = append(m.CfgInfo, &FingerprintInfo{})
			if err := m.CfgInfo[len(m.CfgInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDhcpserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OptionsInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OptionsInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OptionsInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionId", wireType)
			}
			m.OptionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolType", wireType)
			}
			m.ProtocolType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtocolType |= ProtocolType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetId", wireType)
			}
			m.SubnetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubnetId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDhcpserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OptionsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OptionsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OptionsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperType", wireType)
			}
			m.OperType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperType |= OperationType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = append(m.Info, &OptionsInfo{})
			if err := m.Info[len(m.Info)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDhcpserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OptionsRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OptionsRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OptionsRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDhcpserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = append(m.Info, &OptionsInfo{})
			if err := m.Info[len(m.Info)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDhcpserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDhcpserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDhcpserver(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDhcpserver
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDhcpserver
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDhcpserver
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDhcpserver
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDhcpserver
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDhcpserver        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDhcpserver          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDhcpserver = fmt.Errorf("proto: unexpected end of group")
)
