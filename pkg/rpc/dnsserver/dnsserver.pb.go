// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: dnsserver.proto

package dnsserver

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

//操作类型
type OperType int32

const (
	OperType_NONE OperType = 0
	OperType_ADD  OperType = 1
	OperType_DEL  OperType = 2
	OperType_MOD  OperType = 3
)

var OperType_name = map[int32]string{
	0: "NONE",
	1: "ADD",
	2: "DEL",
	3: "MOD",
}

var OperType_value = map[string]int32{
	"NONE": 0,
	"ADD":  1,
	"DEL":  2,
	"MOD":  3,
}

func (x OperType) String() string {
	return proto.EnumName(OperType_name, int32(x))
}

func (OperType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_60dfd4b9df933ee0, []int{0}
}

type ForwardRefer struct {
	DomainId             uint64   `protobuf:"varint,1,opt,name=domain_id,json=domainId,proto3" json:"domain_id,omitempty"`
	ForwardId            uint64   `protobuf:"varint,2,opt,name=forward_id,json=forwardId,proto3" json:"forward_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ForwardRefer) Reset()         { *m = ForwardRefer{} }
func (m *ForwardRefer) String() string { return proto.CompactTextString(m) }
func (*ForwardRefer) ProtoMessage()    {}
func (*ForwardRefer) Descriptor() ([]byte, []int) {
	return fileDescriptor_60dfd4b9df933ee0, []int{0}
}
func (m *ForwardRefer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ForwardRefer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ForwardRefer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ForwardRefer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForwardRefer.Merge(m, src)
}
func (m *ForwardRefer) XXX_Size() int {
	return m.Size()
}
func (m *ForwardRefer) XXX_DiscardUnknown() {
	xxx_messageInfo_ForwardRefer.DiscardUnknown(m)
}

var xxx_messageInfo_ForwardRefer proto.InternalMessageInfo

func (m *ForwardRefer) GetDomainId() uint64 {
	if m != nil {
		return m.DomainId
	}
	return 0
}

func (m *ForwardRefer) GetForwardId() uint64 {
	if m != nil {
		return m.ForwardId
	}
	return 0
}

type ForwardEnableMsg struct {
	Refer                *ForwardRefer `protobuf:"bytes,1,opt,name=refer,proto3" json:"refer,omitempty"`
	Enable               bool          `protobuf:"varint,2,opt,name=enable,proto3" json:"enable,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ForwardEnableMsg) Reset()         { *m = ForwardEnableMsg{} }
func (m *ForwardEnableMsg) String() string { return proto.CompactTextString(m) }
func (*ForwardEnableMsg) ProtoMessage()    {}
func (*ForwardEnableMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_60dfd4b9df933ee0, []int{1}
}
func (m *ForwardEnableMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ForwardEnableMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ForwardEnableMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ForwardEnableMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForwardEnableMsg.Merge(m, src)
}
func (m *ForwardEnableMsg) XXX_Size() int {
	return m.Size()
}
func (m *ForwardEnableMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_ForwardEnableMsg.DiscardUnknown(m)
}

var xxx_messageInfo_ForwardEnableMsg proto.InternalMessageInfo

func (m *ForwardEnableMsg) GetRefer() *ForwardRefer {
	if m != nil {
		return m.Refer
	}
	return nil
}

func (m *ForwardEnableMsg) GetEnable() bool {
	if m != nil {
		return m.Enable
	}
	return false
}

//通用响应,0为成功,非0失败
//{1001, "Access etcd failed."} {1002, "The index is invalid."}
//{1003, "Invalid parameter."} {1004, "The record does not exist."}
type ReqStatus struct {
	Id                   []uint64 `protobuf:"varint,1,rep,packed,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReqStatus) Reset()         { *m = ReqStatus{} }
func (m *ReqStatus) String() string { return proto.CompactTextString(m) }
func (*ReqStatus) ProtoMessage()    {}
func (*ReqStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_60dfd4b9df933ee0, []int{2}
}
func (m *ReqStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReqStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReqStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReqStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReqStatus.Merge(m, src)
}
func (m *ReqStatus) XXX_Size() int {
	return m.Size()
}
func (m *ReqStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ReqStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ReqStatus proto.InternalMessageInfo

func (m *ReqStatus) GetId() []uint64 {
	if m != nil {
		return m.Id
	}
	return nil
}

//通用响应
type RespStatus struct {
	Code                 int32    `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Msg                  string   `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RespStatus) Reset()         { *m = RespStatus{} }
func (m *RespStatus) String() string { return proto.CompactTextString(m) }
func (*RespStatus) ProtoMessage()    {}
func (*RespStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_60dfd4b9df933ee0, []int{3}
}
func (m *RespStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RespStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RespStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RespStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RespStatus.Merge(m, src)
}
func (m *RespStatus) XXX_Size() int {
	return m.Size()
}
func (m *RespStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_RespStatus.DiscardUnknown(m)
}

var xxx_messageInfo_RespStatus proto.InternalMessageInfo

func (m *RespStatus) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *RespStatus) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

//正向域名信息
type ForwardInfos struct {
	OperateType          OperType       `protobuf:"varint,1,opt,name=operate_type,json=operateType,proto3,enum=dnsserver.OperType" json:"operate_type,omitempty"`
	Ev                   []*ForwardInfo `protobuf:"bytes,2,rep,name=ev,proto3" json:"ev,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ForwardInfos) Reset()         { *m = ForwardInfos{} }
func (m *ForwardInfos) String() string { return proto.CompactTextString(m) }
func (*ForwardInfos) ProtoMessage()    {}
func (*ForwardInfos) Descriptor() ([]byte, []int) {
	return fileDescriptor_60dfd4b9df933ee0, []int{4}
}
func (m *ForwardInfos) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ForwardInfos) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ForwardInfos.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ForwardInfos) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForwardInfos.Merge(m, src)
}
func (m *ForwardInfos) XXX_Size() int {
	return m.Size()
}
func (m *ForwardInfos) XXX_DiscardUnknown() {
	xxx_messageInfo_ForwardInfos.DiscardUnknown(m)
}

var xxx_messageInfo_ForwardInfos proto.InternalMessageInfo

func (m *ForwardInfos) GetOperateType() OperType {
	if m != nil {
		return m.OperateType
	}
	return OperType_NONE
}

func (m *ForwardInfos) GetEv() []*ForwardInfo {
	if m != nil {
		return m.Ev
	}
	return nil
}

type ForwardInfo struct {
	Id                   uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Domain               string   `protobuf:"bytes,2,opt,name=domain,proto3" json:"domain,omitempty"`
	Reference            string   `protobuf:"bytes,3,opt,name=reference,proto3" json:"reference,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ForwardInfo) Reset()         { *m = ForwardInfo{} }
func (m *ForwardInfo) String() string { return proto.CompactTextString(m) }
func (*ForwardInfo) ProtoMessage()    {}
func (*ForwardInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_60dfd4b9df933ee0, []int{5}
}
func (m *ForwardInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ForwardInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ForwardInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ForwardInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForwardInfo.Merge(m, src)
}
func (m *ForwardInfo) XXX_Size() int {
	return m.Size()
}
func (m *ForwardInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ForwardInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ForwardInfo proto.InternalMessageInfo

func (m *ForwardInfo) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ForwardInfo) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *ForwardInfo) GetReference() string {
	if m != nil {
		return m.Reference
	}
	return ""
}

//正向域名记录信息
type DomainInfos struct {
	OperateType          OperType      `protobuf:"varint,1,opt,name=operate_type,json=operateType,proto3,enum=dnsserver.OperType" json:"operate_type,omitempty"`
	Ev                   []*DomainInfo `protobuf:"bytes,2,rep,name=ev,proto3" json:"ev,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *DomainInfos) Reset()         { *m = DomainInfos{} }
func (m *DomainInfos) String() string { return proto.CompactTextString(m) }
func (*DomainInfos) ProtoMessage()    {}
func (*DomainInfos) Descriptor() ([]byte, []int) {
	return fileDescriptor_60dfd4b9df933ee0, []int{6}
}
func (m *DomainInfos) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DomainInfos) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DomainInfos.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DomainInfos) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DomainInfos.Merge(m, src)
}
func (m *DomainInfos) XXX_Size() int {
	return m.Size()
}
func (m *DomainInfos) XXX_DiscardUnknown() {
	xxx_messageInfo_DomainInfos.DiscardUnknown(m)
}

var xxx_messageInfo_DomainInfos proto.InternalMessageInfo

func (m *DomainInfos) GetOperateType() OperType {
	if m != nil {
		return m.OperateType
	}
	return OperType_NONE
}

func (m *DomainInfos) GetEv() []*DomainInfo {
	if m != nil {
		return m.Ev
	}
	return nil
}

type DomainInfo struct {
	Id                   uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	ForId                uint64   `protobuf:"varint,2,opt,name=for_id,json=forId,proto3" json:"for_id,omitempty"`
	Name                 string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Type                 string   `protobuf:"bytes,4,opt,name=type,proto3" json:"type,omitempty"`
	IspId                uint64   `protobuf:"varint,5,opt,name=isp_id,json=ispId,proto3" json:"isp_id,omitempty"`
	Value                string   `protobuf:"bytes,6,opt,name=value,proto3" json:"value,omitempty"`
	Ttl                  int32    `protobuf:"varint,7,opt,name=ttl,proto3" json:"ttl,omitempty"`
	Mx                   int32    `protobuf:"varint,8,opt,name=mx,proto3" json:"mx,omitempty"`
	Enable               bool     `protobuf:"varint,9,opt,name=enable,proto3" json:"enable,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DomainInfo) Reset()         { *m = DomainInfo{} }
func (m *DomainInfo) String() string { return proto.CompactTextString(m) }
func (*DomainInfo) ProtoMessage()    {}
func (*DomainInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_60dfd4b9df933ee0, []int{7}
}
func (m *DomainInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DomainInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DomainInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DomainInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DomainInfo.Merge(m, src)
}
func (m *DomainInfo) XXX_Size() int {
	return m.Size()
}
func (m *DomainInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DomainInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DomainInfo proto.InternalMessageInfo

func (m *DomainInfo) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *DomainInfo) GetForId() uint64 {
	if m != nil {
		return m.ForId
	}
	return 0
}

func (m *DomainInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DomainInfo) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *DomainInfo) GetIspId() uint64 {
	if m != nil {
		return m.IspId
	}
	return 0
}

func (m *DomainInfo) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *DomainInfo) GetTtl() int32 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

func (m *DomainInfo) GetMx() int32 {
	if m != nil {
		return m.Mx
	}
	return 0
}

func (m *DomainInfo) GetEnable() bool {
	if m != nil {
		return m.Enable
	}
	return false
}

//使能信息
type EnableInfos struct {
	Id                   uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Enable               bool     `protobuf:"varint,2,opt,name=enable,proto3" json:"enable,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EnableInfos) Reset()         { *m = EnableInfos{} }
func (m *EnableInfos) String() string { return proto.CompactTextString(m) }
func (*EnableInfos) ProtoMessage()    {}
func (*EnableInfos) Descriptor() ([]byte, []int) {
	return fileDescriptor_60dfd4b9df933ee0, []int{8}
}
func (m *EnableInfos) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnableInfos) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnableInfos.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EnableInfos) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnableInfos.Merge(m, src)
}
func (m *EnableInfos) XXX_Size() int {
	return m.Size()
}
func (m *EnableInfos) XXX_DiscardUnknown() {
	xxx_messageInfo_EnableInfos.DiscardUnknown(m)
}

var xxx_messageInfo_EnableInfos proto.InternalMessageInfo

func (m *EnableInfos) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *EnableInfos) GetEnable() bool {
	if m != nil {
		return m.Enable
	}
	return false
}

//递归解析信息
type RecursionInfo struct {
	RecursionEnable      bool     `protobuf:"varint,1,opt,name=recursion_enable,json=recursionEnable,proto3" json:"recursion_enable,omitempty"`
	Dns46Enable          bool     `protobuf:"varint,2,opt,name=dns46_enable,json=dns46Enable,proto3" json:"dns46_enable,omitempty"`
	Dns64Enable          bool     `protobuf:"varint,3,opt,name=dns64_enable,json=dns64Enable,proto3" json:"dns64_enable,omitempty"`
	Dns64Synthall        bool     `protobuf:"varint,4,opt,name=dns64_synthall,json=dns64Synthall,proto3" json:"dns64_synthall,omitempty"`
	Dns64Prefix          string   `protobuf:"bytes,5,opt,name=dns64_prefix,json=dns64Prefix,proto3" json:"dns64_prefix,omitempty"`
	JumpAddr             string   `protobuf:"bytes,6,opt,name=jump_addr,json=jumpAddr,proto3" json:"jump_addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RecursionInfo) Reset()         { *m = RecursionInfo{} }
func (m *RecursionInfo) String() string { return proto.CompactTextString(m) }
func (*RecursionInfo) ProtoMessage()    {}
func (*RecursionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_60dfd4b9df933ee0, []int{9}
}
func (m *RecursionInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecursionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecursionInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecursionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecursionInfo.Merge(m, src)
}
func (m *RecursionInfo) XXX_Size() int {
	return m.Size()
}
func (m *RecursionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RecursionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RecursionInfo proto.InternalMessageInfo

func (m *RecursionInfo) GetRecursionEnable() bool {
	if m != nil {
		return m.RecursionEnable
	}
	return false
}

func (m *RecursionInfo) GetDns46Enable() bool {
	if m != nil {
		return m.Dns46Enable
	}
	return false
}

func (m *RecursionInfo) GetDns64Enable() bool {
	if m != nil {
		return m.Dns64Enable
	}
	return false
}

func (m *RecursionInfo) GetDns64Synthall() bool {
	if m != nil {
		return m.Dns64Synthall
	}
	return false
}

func (m *RecursionInfo) GetDns64Prefix() string {
	if m != nil {
		return m.Dns64Prefix
	}
	return ""
}

func (m *RecursionInfo) GetJumpAddr() string {
	if m != nil {
		return m.JumpAddr
	}
	return ""
}

//转发配置信息
type TransferInfos struct {
	OperateType          OperType        `protobuf:"varint,1,opt,name=operate_type,json=operateType,proto3,enum=dnsserver.OperType" json:"operate_type,omitempty"`
	Ev                   []*TransferInfo `protobuf:"bytes,2,rep,name=ev,proto3" json:"ev,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *TransferInfos) Reset()         { *m = TransferInfos{} }
func (m *TransferInfos) String() string { return proto.CompactTextString(m) }
func (*TransferInfos) ProtoMessage()    {}
func (*TransferInfos) Descriptor() ([]byte, []int) {
	return fileDescriptor_60dfd4b9df933ee0, []int{10}
}
func (m *TransferInfos) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferInfos) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferInfos.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferInfos) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferInfos.Merge(m, src)
}
func (m *TransferInfos) XXX_Size() int {
	return m.Size()
}
func (m *TransferInfos) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferInfos.DiscardUnknown(m)
}

var xxx_messageInfo_TransferInfos proto.InternalMessageInfo

func (m *TransferInfos) GetOperateType() OperType {
	if m != nil {
		return m.OperateType
	}
	return OperType_NONE
}

func (m *TransferInfos) GetEv() []*TransferInfo {
	if m != nil {
		return m.Ev
	}
	return nil
}

type TransferInfo struct {
	Id                   uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Domain               string   `protobuf:"bytes,2,opt,name=domain,proto3" json:"domain,omitempty"`
	Ip                   string   `protobuf:"bytes,3,opt,name=ip,proto3" json:"ip,omitempty"`
	Enable               bool     `protobuf:"varint,4,opt,name=enable,proto3" json:"enable,omitempty"`
	Reference            string   `protobuf:"bytes,5,opt,name=reference,proto3" json:"reference,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TransferInfo) Reset()         { *m = TransferInfo{} }
func (m *TransferInfo) String() string { return proto.CompactTextString(m) }
func (*TransferInfo) ProtoMessage()    {}
func (*TransferInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_60dfd4b9df933ee0, []int{11}
}
func (m *TransferInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferInfo.Merge(m, src)
}
func (m *TransferInfo) XXX_Size() int {
	return m.Size()
}
func (m *TransferInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TransferInfo proto.InternalMessageInfo

func (m *TransferInfo) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TransferInfo) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *TransferInfo) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *TransferInfo) GetEnable() bool {
	if m != nil {
		return m.Enable
	}
	return false
}

func (m *TransferInfo) GetReference() string {
	if m != nil {
		return m.Reference
	}
	return ""
}

//服务配置信息
type SysConfs struct {
	Sys                  *SysConf         `protobuf:"bytes,1,opt,name=sys,proto3" json:"sys,omitempty"`
	Info                 *RecursionInfo   `protobuf:"bytes,2,opt,name=info,proto3" json:"info,omitempty"`
	Ip                   []*ServiceIPInfo `protobuf:"bytes,3,rep,name=ip,proto3" json:"ip,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *SysConfs) Reset()         { *m = SysConfs{} }
func (m *SysConfs) String() string { return proto.CompactTextString(m) }
func (*SysConfs) ProtoMessage()    {}
func (*SysConfs) Descriptor() ([]byte, []int) {
	return fileDescriptor_60dfd4b9df933ee0, []int{12}
}
func (m *SysConfs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SysConfs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SysConfs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SysConfs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SysConfs.Merge(m, src)
}
func (m *SysConfs) XXX_Size() int {
	return m.Size()
}
func (m *SysConfs) XXX_DiscardUnknown() {
	xxx_messageInfo_SysConfs.DiscardUnknown(m)
}

var xxx_messageInfo_SysConfs proto.InternalMessageInfo

func (m *SysConfs) GetSys() *SysConf {
	if m != nil {
		return m.Sys
	}
	return nil
}

func (m *SysConfs) GetInfo() *RecursionInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *SysConfs) GetIp() []*ServiceIPInfo {
	if m != nil {
		return m.Ip
	}
	return nil
}

type SysConf struct {
	Port                 int32    `protobuf:"varint,1,opt,name=port,proto3" json:"port,omitempty"`
	CnamePriority        bool     `protobuf:"varint,2,opt,name=cname_priority,json=cnamePriority,proto3" json:"cname_priority,omitempty"`
	TcpEnable            bool     `protobuf:"varint,3,opt,name=tcp_enable,json=tcpEnable,proto3" json:"tcp_enable,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SysConf) Reset()         { *m = SysConf{} }
func (m *SysConf) String() string { return proto.CompactTextString(m) }
func (*SysConf) ProtoMessage()    {}
func (*SysConf) Descriptor() ([]byte, []int) {
	return fileDescriptor_60dfd4b9df933ee0, []int{13}
}
func (m *SysConf) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SysConf) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SysConf.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SysConf) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SysConf.Merge(m, src)
}
func (m *SysConf) XXX_Size() int {
	return m.Size()
}
func (m *SysConf) XXX_DiscardUnknown() {
	xxx_messageInfo_SysConf.DiscardUnknown(m)
}

var xxx_messageInfo_SysConf proto.InternalMessageInfo

func (m *SysConf) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *SysConf) GetCnamePriority() bool {
	if m != nil {
		return m.CnamePriority
	}
	return false
}

func (m *SysConf) GetTcpEnable() bool {
	if m != nil {
		return m.TcpEnable
	}
	return false
}

type ServiceIPInfo struct {
	Ip                   string   `protobuf:"bytes,1,opt,name=ip,proto3" json:"ip,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServiceIPInfo) Reset()         { *m = ServiceIPInfo{} }
func (m *ServiceIPInfo) String() string { return proto.CompactTextString(m) }
func (*ServiceIPInfo) ProtoMessage()    {}
func (*ServiceIPInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_60dfd4b9df933ee0, []int{14}
}
func (m *ServiceIPInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceIPInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceIPInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceIPInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceIPInfo.Merge(m, src)
}
func (m *ServiceIPInfo) XXX_Size() int {
	return m.Size()
}
func (m *ServiceIPInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceIPInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceIPInfo proto.InternalMessageInfo

func (m *ServiceIPInfo) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

//正向域名记录解析状态
type ForwardStatusInfos struct {
	Ev                   []*ForStatusInfo `protobuf:"bytes,1,rep,name=ev,proto3" json:"ev,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ForwardStatusInfos) Reset()         { *m = ForwardStatusInfos{} }
func (m *ForwardStatusInfos) String() string { return proto.CompactTextString(m) }
func (*ForwardStatusInfos) ProtoMessage()    {}
func (*ForwardStatusInfos) Descriptor() ([]byte, []int) {
	return fileDescriptor_60dfd4b9df933ee0, []int{15}
}
func (m *ForwardStatusInfos) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ForwardStatusInfos) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ForwardStatusInfos.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ForwardStatusInfos) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForwardStatusInfos.Merge(m, src)
}
func (m *ForwardStatusInfos) XXX_Size() int {
	return m.Size()
}
func (m *ForwardStatusInfos) XXX_DiscardUnknown() {
	xxx_messageInfo_ForwardStatusInfos.DiscardUnknown(m)
}

var xxx_messageInfo_ForwardStatusInfos proto.InternalMessageInfo

func (m *ForwardStatusInfos) GetEv() []*ForStatusInfo {
	if m != nil {
		return m.Ev
	}
	return nil
}

type ForStatusInfo struct {
	Refer                *ForwardRefer `protobuf:"bytes,1,opt,name=refer,proto3" json:"refer,omitempty"`
	Status               int32         `protobuf:"varint,2,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ForStatusInfo) Reset()         { *m = ForStatusInfo{} }
func (m *ForStatusInfo) String() string { return proto.CompactTextString(m) }
func (*ForStatusInfo) ProtoMessage()    {}
func (*ForStatusInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_60dfd4b9df933ee0, []int{16}
}
func (m *ForStatusInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ForStatusInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ForStatusInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ForStatusInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForStatusInfo.Merge(m, src)
}
func (m *ForStatusInfo) XXX_Size() int {
	return m.Size()
}
func (m *ForStatusInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ForStatusInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ForStatusInfo proto.InternalMessageInfo

func (m *ForStatusInfo) GetRefer() *ForwardRefer {
	if m != nil {
		return m.Refer
	}
	return nil
}

func (m *ForStatusInfo) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

type RespServiceIP struct {
	Ip                   []*ServiceIPInfo `protobuf:"bytes,1,rep,name=ip,proto3" json:"ip,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *RespServiceIP) Reset()         { *m = RespServiceIP{} }
func (m *RespServiceIP) String() string { return proto.CompactTextString(m) }
func (*RespServiceIP) ProtoMessage()    {}
func (*RespServiceIP) Descriptor() ([]byte, []int) {
	return fileDescriptor_60dfd4b9df933ee0, []int{17}
}
func (m *RespServiceIP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RespServiceIP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RespServiceIP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RespServiceIP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RespServiceIP.Merge(m, src)
}
func (m *RespServiceIP) XXX_Size() int {
	return m.Size()
}
func (m *RespServiceIP) XXX_DiscardUnknown() {
	xxx_messageInfo_RespServiceIP.DiscardUnknown(m)
}

var xxx_messageInfo_RespServiceIP proto.InternalMessageInfo

func (m *RespServiceIP) GetIp() []*ServiceIPInfo {
	if m != nil {
		return m.Ip
	}
	return nil
}

func init() {
	proto.RegisterEnum("dnsserver.OperType", OperType_name, OperType_value)
	proto.RegisterType((*ForwardRefer)(nil), "dnsserver.ForwardRefer")
	proto.RegisterType((*ForwardEnableMsg)(nil), "dnsserver.ForwardEnableMsg")
	proto.RegisterType((*ReqStatus)(nil), "dnsserver.ReqStatus")
	proto.RegisterType((*RespStatus)(nil), "dnsserver.RespStatus")
	proto.RegisterType((*ForwardInfos)(nil), "dnsserver.ForwardInfos")
	proto.RegisterType((*ForwardInfo)(nil), "dnsserver.ForwardInfo")
	proto.RegisterType((*DomainInfos)(nil), "dnsserver.DomainInfos")
	proto.RegisterType((*DomainInfo)(nil), "dnsserver.DomainInfo")
	proto.RegisterType((*EnableInfos)(nil), "dnsserver.EnableInfos")
	proto.RegisterType((*RecursionInfo)(nil), "dnsserver.RecursionInfo")
	proto.RegisterType((*TransferInfos)(nil), "dnsserver.TransferInfos")
	proto.RegisterType((*TransferInfo)(nil), "dnsserver.TransferInfo")
	proto.RegisterType((*SysConfs)(nil), "dnsserver.SysConfs")
	proto.RegisterType((*SysConf)(nil), "dnsserver.SysConf")
	proto.RegisterType((*ServiceIPInfo)(nil), "dnsserver.ServiceIPInfo")
	proto.RegisterType((*ForwardStatusInfos)(nil), "dnsserver.ForwardStatusInfos")
	proto.RegisterType((*ForStatusInfo)(nil), "dnsserver.ForStatusInfo")
	proto.RegisterType((*RespServiceIP)(nil), "dnsserver.RespServiceIP")
}

func init() { proto.RegisterFile("dnsserver.proto", fileDescriptor_60dfd4b9df933ee0) }

var fileDescriptor_60dfd4b9df933ee0 = []byte{
	// 1003 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xdd, 0x6e, 0xe3, 0x44,
	0x14, 0x8e, 0xed, 0x24, 0x8d, 0x8f, 0x93, 0xd4, 0x9a, 0xdd, 0x76, 0xa3, 0x96, 0x2d, 0x8b, 0xc5,
	0x42, 0x40, 0xb0, 0x48, 0xa1, 0x54, 0xda, 0x8b, 0x5d, 0x68, 0x49, 0xb7, 0x0a, 0xa2, 0xdb, 0xe2,
	0x2c, 0x48, 0x5c, 0x45, 0xde, 0x78, 0x5c, 0x8c, 0x12, 0x7b, 0x98, 0x71, 0x42, 0x23, 0xf1, 0x00,
	0x3c, 0x02, 0xef, 0xc1, 0x1b, 0x70, 0xc5, 0x25, 0x8f, 0x80, 0xca, 0x05, 0xaf, 0x81, 0xe6, 0xc7,
	0x7f, 0x9b, 0x98, 0x45, 0xf4, 0x6e, 0xfc, 0xf9, 0x3b, 0x67, 0xce, 0xcf, 0x77, 0x8e, 0x0d, 0xdb,
	0x7e, 0xc4, 0x18, 0xa6, 0x4b, 0x4c, 0x1f, 0x11, 0x1a, 0x27, 0x31, 0x32, 0x33, 0xc0, 0xf9, 0x02,
	0xda, 0xcf, 0x62, 0xfa, 0xa3, 0x47, 0x7d, 0x17, 0x07, 0x98, 0xa2, 0x7d, 0x30, 0xfd, 0x78, 0xee,
	0x85, 0xd1, 0x24, 0xf4, 0x7b, 0xda, 0x03, 0xad, 0x5f, 0x77, 0x5b, 0x12, 0x18, 0xf9, 0xe8, 0x3e,
	0x40, 0x20, 0xc9, 0xfc, 0xad, 0x2e, 0xde, 0x9a, 0x0a, 0x19, 0xf9, 0xce, 0xb7, 0x60, 0x2b, 0x5f,
	0xa7, 0x91, 0xf7, 0x72, 0x86, 0xcf, 0xd9, 0x15, 0xfa, 0x10, 0x1a, 0x94, 0x3b, 0x16, 0xbe, 0xac,
	0xc1, 0xbd, 0x47, 0x79, 0x2c, 0xc5, 0x7b, 0x5d, 0xc9, 0x42, 0xbb, 0xd0, 0xc4, 0xc2, 0x56, 0x78,
	0x6f, 0xb9, 0xea, 0xc9, 0xd9, 0x07, 0xd3, 0xc5, 0x3f, 0x8c, 0x13, 0x2f, 0x59, 0x30, 0xd4, 0x05,
	0x5d, 0x04, 0x67, 0xf4, 0xeb, 0xae, 0x1e, 0xfa, 0xce, 0x00, 0xc0, 0xc5, 0x8c, 0xa8, 0xb7, 0x08,
	0xea, 0xd3, 0xd8, 0xc7, 0xe2, 0xc2, 0x86, 0x2b, 0xce, 0xc8, 0x06, 0x63, 0xce, 0xae, 0x84, 0x4f,
	0xd3, 0xe5, 0x47, 0x27, 0xca, 0xf2, 0x1e, 0x45, 0x41, 0xcc, 0xd0, 0x11, 0xb4, 0x63, 0x82, 0xa9,
	0x97, 0xe0, 0x49, 0xb2, 0x22, 0xd2, 0xba, 0x3b, 0xb8, 0x53, 0x08, 0xf7, 0x82, 0x60, 0xfa, 0x62,
	0x45, 0xb0, 0x6b, 0x29, 0x22, 0x7f, 0x40, 0xef, 0x80, 0x8e, 0x97, 0x3d, 0xfd, 0x81, 0xd1, 0xb7,
	0x06, 0xbb, 0xeb, 0xc9, 0x71, 0xe7, 0xae, 0x8e, 0x97, 0xce, 0x18, 0xac, 0x02, 0x94, 0xa5, 0xa0,
	0xc9, 0x14, 0x78, 0xde, 0xb2, 0xca, 0x2a, 0x46, 0xf5, 0x84, 0xde, 0x00, 0x53, 0x14, 0x06, 0x47,
	0x53, 0xdc, 0x33, 0xc4, 0xab, 0x1c, 0x70, 0x66, 0x60, 0x0d, 0x65, 0x6f, 0x6e, 0x95, 0xc3, 0xc3,
	0x42, 0x0e, 0x3b, 0x05, 0x76, 0xee, 0x5b, 0xa4, 0xf0, 0x9b, 0x06, 0x90, 0x43, 0x6b, 0x29, 0xec,
	0x40, 0x33, 0x88, 0x69, 0x2e, 0x8c, 0x46, 0x10, 0xd3, 0x91, 0xcf, 0xdb, 0x11, 0x79, 0xf3, 0x34,
	0x78, 0x71, 0xe6, 0x98, 0x08, 0xb0, 0x2e, 0x31, 0x7e, 0xe6, 0xe6, 0x21, 0x23, 0xdc, 0xbc, 0x21,
	0xcd, 0x43, 0x46, 0x46, 0x3e, 0xba, 0x0b, 0x8d, 0xa5, 0x37, 0x5b, 0xe0, 0x5e, 0x53, 0x70, 0xe5,
	0x03, 0xef, 0x67, 0x92, 0xcc, 0x7a, 0x5b, 0xa2, 0xc5, 0xfc, 0xc8, 0xa3, 0x99, 0x5f, 0xf7, 0x5a,
	0x02, 0xd0, 0xe7, 0xd7, 0x05, 0x21, 0x99, 0x25, 0x21, 0x7d, 0x02, 0x96, 0x14, 0xa7, 0x2c, 0xd9,
	0x86, 0x3e, 0x6c, 0xd4, 0xdf, 0xdf, 0x1a, 0x74, 0x5c, 0x3c, 0x5d, 0x50, 0x16, 0xc6, 0x32, 0xfd,
	0xf7, 0xc0, 0xa6, 0x29, 0x30, 0x51, 0x36, 0x9a, 0xb0, 0xd9, 0xce, 0x70, 0x79, 0x13, 0x7a, 0x0b,
	0xda, 0x7e, 0xc4, 0x0e, 0x8f, 0x26, 0x25, 0xd7, 0x96, 0xc0, 0x4a, 0x94, 0xa3, 0xc3, 0x94, 0x62,
	0x64, 0x94, 0xa3, 0x43, 0x45, 0x79, 0x08, 0x5d, 0x49, 0x61, 0xab, 0x28, 0xf9, 0xce, 0x9b, 0xcd,
	0x44, 0xf9, 0x5a, 0x6e, 0x47, 0xa0, 0x63, 0x05, 0xe6, 0x9e, 0x08, 0xc5, 0x41, 0x78, 0x2d, 0xaa,
	0x69, 0x2a, 0x4f, 0x97, 0x02, 0xe2, 0x33, 0xfe, 0xfd, 0x62, 0x4e, 0x26, 0x9e, 0xef, 0x53, 0x55,
	0xd7, 0x16, 0x07, 0x8e, 0x7d, 0x9f, 0x3a, 0x04, 0x3a, 0x2f, 0xa8, 0x17, 0xb1, 0x00, 0xd3, 0xdb,
	0xa9, 0xea, 0xdd, 0x82, 0xaa, 0x8a, 0x63, 0x5f, 0xf4, 0x2e, 0x74, 0xf5, 0x13, 0xb4, 0x8b, 0xd8,
	0x7f, 0x9e, 0x0d, 0xce, 0x23, 0x4a, 0x57, 0x7a, 0x48, 0x0a, 0xbd, 0xab, 0x17, 0x7b, 0x57, 0x9e,
	0xa1, 0xc6, 0xab, 0x33, 0xf4, 0xb3, 0x06, 0xad, 0xf1, 0x8a, 0x7d, 0x1e, 0x47, 0x01, 0x43, 0x6f,
	0x83, 0xc1, 0x56, 0x4c, 0xed, 0x2a, 0x54, 0x08, 0x5a, 0x31, 0x5c, 0xfe, 0x1a, 0x7d, 0x00, 0xf5,
	0x30, 0x0a, 0x62, 0x11, 0x8e, 0x35, 0xe8, 0x15, 0x68, 0x25, 0x89, 0xb8, 0x82, 0x85, 0xfa, 0x2a,
	0x4c, 0xe3, 0x15, 0xee, 0x18, 0xd3, 0x65, 0x38, 0xc5, 0xa3, 0x4b, 0x59, 0x88, 0x90, 0x38, 0x53,
	0xd8, 0x52, 0xf7, 0xf0, 0x09, 0x21, 0x31, 0x4d, 0xd2, 0x25, 0xc6, 0xcf, 0x5c, 0x00, 0x53, 0x3e,
	0x3e, 0x13, 0x42, 0xc3, 0x98, 0x86, 0xc9, 0x4a, 0x09, 0xa9, 0x23, 0xd0, 0x4b, 0x05, 0xf2, 0x25,
	0x9d, 0x4c, 0x49, 0x59, 0x48, 0x66, 0x32, 0x25, 0x52, 0x46, 0xce, 0x9b, 0xd0, 0x29, 0xdd, 0xac,
	0xca, 0xa8, 0xa5, 0x65, 0x74, 0x9e, 0x02, 0x52, 0x9b, 0x4a, 0x2e, 0x54, 0xa9, 0x82, 0xbe, 0xe8,
	0xa6, 0xb6, 0x96, 0xc5, 0xb3, 0x98, 0xe6, 0x34, 0xd1, 0xce, 0x6f, 0xa0, 0x53, 0x02, 0xff, 0xc7,
	0x27, 0x80, 0x09, 0x63, 0x91, 0x5e, 0xc3, 0x55, 0x4f, 0xce, 0x63, 0x3e, 0x81, 0x8c, 0x64, 0xc1,
	0xab, 0xc2, 0x6a, 0xaf, 0x2f, 0xec, 0xfb, 0x1f, 0x41, 0x2b, 0xd5, 0x28, 0x6a, 0x41, 0xfd, 0xf9,
	0xc5, 0xf3, 0x53, 0xbb, 0x86, 0xb6, 0xc0, 0x38, 0x1e, 0x0e, 0x6d, 0x8d, 0x1f, 0x86, 0xa7, 0x5f,
	0xda, 0x3a, 0x3f, 0x9c, 0x5f, 0x0c, 0x6d, 0x63, 0xf0, 0x6b, 0x13, 0x60, 0x18, 0xb1, 0x73, 0x2f,
	0xf2, 0xae, 0x30, 0x45, 0x4f, 0x00, 0xce, 0x70, 0xa2, 0x82, 0x45, 0x77, 0x4b, 0x0d, 0x57, 0x1f,
	0xa5, 0xbd, 0x7b, 0x9b, 0x97, 0x3f, 0x73, 0x6a, 0xe8, 0x04, 0xba, 0x17, 0x72, 0x30, 0x52, 0x17,
	0x55, 0xe4, 0xbd, 0x9d, 0x92, 0xef, 0xf4, 0x9b, 0xe6, 0xd4, 0xd0, 0x53, 0x30, 0xcf, 0x70, 0x22,
	0xd7, 0x2f, 0xaa, 0x2a, 0xe1, 0xde, 0xee, 0xc6, 0xed, 0xcd, 0xed, 0x3f, 0x83, 0x8e, 0x8a, 0x41,
	0xf9, 0xa8, 0xa0, 0x56, 0x47, 0x30, 0x84, 0xb6, 0x94, 0x90, 0x72, 0xb0, 0xbf, 0x1e, 0x44, 0xf6,
	0xd9, 0xaf, 0xf6, 0xf2, 0x29, 0x58, 0x67, 0x38, 0x49, 0xe7, 0xbd, 0xa2, 0x96, 0xbd, 0x8a, 0x75,
	0x21, 0xc3, 0xd8, 0x56, 0x89, 0x64, 0x4e, 0x2a, 0xe9, 0xd5, 0x61, 0x1c, 0x43, 0x57, 0x06, 0x9b,
	0x39, 0x29, 0xd6, 0xa3, 0xf0, 0x85, 0xa8, 0x76, 0xf1, 0x58, 0x88, 0x22, 0x1d, 0xd8, 0xcd, 0x89,
	0xdc, 0x59, 0x5f, 0x21, 0xdc, 0xf4, 0x09, 0x74, 0xbe, 0x26, 0xbe, 0x97, 0xe0, 0xd4, 0x7a, 0x13,
	0xaf, 0xfa, 0xe6, 0x13, 0xe8, 0x7e, 0xb5, 0xc0, 0x74, 0x95, 0x8f, 0xc2, 0xeb, 0xcb, 0x58, 0x1a,
	0x1d, 0xa7, 0x86, 0x5c, 0xb0, 0x73, 0x49, 0xab, 0x3f, 0xa7, 0xfb, 0xeb, 0x1d, 0x2d, 0xac, 0x80,
	0xbd, 0x7f, 0x7f, 0xed, 0xd4, 0x4e, 0xec, 0xdf, 0x6f, 0x0e, 0xb4, 0x3f, 0x6e, 0x0e, 0xb4, 0x3f,
	0x6f, 0x0e, 0xb4, 0x5f, 0xfe, 0x3a, 0xa8, 0xbd, 0x6c, 0x8a, 0xff, 0xcd, 0x8f, 0xff, 0x09, 0x00,
	0x00, 0xff, 0xff, 0x0f, 0x5d, 0x19, 0xf7, 0x82, 0x0a, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// DnsManagerClient is the client API for DnsManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DnsManagerClient interface {
	//正向域名
	GetForward(ctx context.Context, in *ReqStatus, opts ...grpc.CallOption) (*ForwardInfos, error)
	OperateForward(ctx context.Context, in *ForwardInfos, opts ...grpc.CallOption) (*RespStatus, error)
	//正向域名记录
	GetDomain(ctx context.Context, in *ForwardRefer, opts ...grpc.CallOption) (*DomainInfos, error)
	OperateDomain(ctx context.Context, in *DomainInfos, opts ...grpc.CallOption) (*RespStatus, error)
	//正向域名记录使能
	EnableDomain(ctx context.Context, in *ForwardEnableMsg, opts ...grpc.CallOption) (*RespStatus, error)
	//转发配置
	GetTransfer(ctx context.Context, in *ReqStatus, opts ...grpc.CallOption) (*TransferInfos, error)
	OperateTransfer(ctx context.Context, in *TransferInfos, opts ...grpc.CallOption) (*RespStatus, error)
	//转发使能
	EnableTransfer(ctx context.Context, in *EnableInfos, opts ...grpc.CallOption) (*RespStatus, error)
	//服务配置
	GetSysConf(ctx context.Context, in *ReqStatus, opts ...grpc.CallOption) (*SysConfs, error)
	UpdateSysConf(ctx context.Context, in *SysConfs, opts ...grpc.CallOption) (*RespStatus, error)
	QueryServiceIP(ctx context.Context, in *ReqStatus, opts ...grpc.CallOption) (*RespServiceIP, error)
	//正向域名记录解析状态
	GetForwardStatus(ctx context.Context, in *ForwardStatusInfos, opts ...grpc.CallOption) (*ForwardStatusInfos, error)
}

type dnsManagerClient struct {
	cc *grpc.ClientConn
}

func NewDnsManagerClient(cc *grpc.ClientConn) DnsManagerClient {
	return &dnsManagerClient{cc}
}

func (c *dnsManagerClient) GetForward(ctx context.Context, in *ReqStatus, opts ...grpc.CallOption) (*ForwardInfos, error) {
	out := new(ForwardInfos)
	err := c.cc.Invoke(ctx, "/dnsserver.DnsManager/GetForward", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dnsManagerClient) OperateForward(ctx context.Context, in *ForwardInfos, opts ...grpc.CallOption) (*RespStatus, error) {
	out := new(RespStatus)
	err := c.cc.Invoke(ctx, "/dnsserver.DnsManager/OperateForward", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dnsManagerClient) GetDomain(ctx context.Context, in *ForwardRefer, opts ...grpc.CallOption) (*DomainInfos, error) {
	out := new(DomainInfos)
	err := c.cc.Invoke(ctx, "/dnsserver.DnsManager/GetDomain", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dnsManagerClient) OperateDomain(ctx context.Context, in *DomainInfos, opts ...grpc.CallOption) (*RespStatus, error) {
	out := new(RespStatus)
	err := c.cc.Invoke(ctx, "/dnsserver.DnsManager/OperateDomain", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dnsManagerClient) EnableDomain(ctx context.Context, in *ForwardEnableMsg, opts ...grpc.CallOption) (*RespStatus, error) {
	out := new(RespStatus)
	err := c.cc.Invoke(ctx, "/dnsserver.DnsManager/EnableDomain", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dnsManagerClient) GetTransfer(ctx context.Context, in *ReqStatus, opts ...grpc.CallOption) (*TransferInfos, error) {
	out := new(TransferInfos)
	err := c.cc.Invoke(ctx, "/dnsserver.DnsManager/GetTransfer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dnsManagerClient) OperateTransfer(ctx context.Context, in *TransferInfos, opts ...grpc.CallOption) (*RespStatus, error) {
	out := new(RespStatus)
	err := c.cc.Invoke(ctx, "/dnsserver.DnsManager/OperateTransfer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dnsManagerClient) EnableTransfer(ctx context.Context, in *EnableInfos, opts ...grpc.CallOption) (*RespStatus, error) {
	out := new(RespStatus)
	err := c.cc.Invoke(ctx, "/dnsserver.DnsManager/EnableTransfer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dnsManagerClient) GetSysConf(ctx context.Context, in *ReqStatus, opts ...grpc.CallOption) (*SysConfs, error) {
	out := new(SysConfs)
	err := c.cc.Invoke(ctx, "/dnsserver.DnsManager/GetSysConf", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dnsManagerClient) UpdateSysConf(ctx context.Context, in *SysConfs, opts ...grpc.CallOption) (*RespStatus, error) {
	out := new(RespStatus)
	err := c.cc.Invoke(ctx, "/dnsserver.DnsManager/UpdateSysConf", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dnsManagerClient) QueryServiceIP(ctx context.Context, in *ReqStatus, opts ...grpc.CallOption) (*RespServiceIP, error) {
	out := new(RespServiceIP)
	err := c.cc.Invoke(ctx, "/dnsserver.DnsManager/QueryServiceIP", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dnsManagerClient) GetForwardStatus(ctx context.Context, in *ForwardStatusInfos, opts ...grpc.CallOption) (*ForwardStatusInfos, error) {
	out := new(ForwardStatusInfos)
	err := c.cc.Invoke(ctx, "/dnsserver.DnsManager/GetForwardStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DnsManagerServer is the server API for DnsManager service.
type DnsManagerServer interface {
	//正向域名
	GetForward(context.Context, *ReqStatus) (*ForwardInfos, error)
	OperateForward(context.Context, *ForwardInfos) (*RespStatus, error)
	//正向域名记录
	GetDomain(context.Context, *ForwardRefer) (*DomainInfos, error)
	OperateDomain(context.Context, *DomainInfos) (*RespStatus, error)
	//正向域名记录使能
	EnableDomain(context.Context, *ForwardEnableMsg) (*RespStatus, error)
	//转发配置
	GetTransfer(context.Context, *ReqStatus) (*TransferInfos, error)
	OperateTransfer(context.Context, *TransferInfos) (*RespStatus, error)
	//转发使能
	EnableTransfer(context.Context, *EnableInfos) (*RespStatus, error)
	//服务配置
	GetSysConf(context.Context, *ReqStatus) (*SysConfs, error)
	UpdateSysConf(context.Context, *SysConfs) (*RespStatus, error)
	QueryServiceIP(context.Context, *ReqStatus) (*RespServiceIP, error)
	//正向域名记录解析状态
	GetForwardStatus(context.Context, *ForwardStatusInfos) (*ForwardStatusInfos, error)
}

// UnimplementedDnsManagerServer can be embedded to have forward compatible implementations.
type UnimplementedDnsManagerServer struct {
}

func (*UnimplementedDnsManagerServer) GetForward(ctx context.Context, req *ReqStatus) (*ForwardInfos, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetForward not implemented")
}
func (*UnimplementedDnsManagerServer) OperateForward(ctx context.Context, req *ForwardInfos) (*RespStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OperateForward not implemented")
}
func (*UnimplementedDnsManagerServer) GetDomain(ctx context.Context, req *ForwardRefer) (*DomainInfos, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDomain not implemented")
}
func (*UnimplementedDnsManagerServer) OperateDomain(ctx context.Context, req *DomainInfos) (*RespStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OperateDomain not implemented")
}
func (*UnimplementedDnsManagerServer) EnableDomain(ctx context.Context, req *ForwardEnableMsg) (*RespStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnableDomain not implemented")
}
func (*UnimplementedDnsManagerServer) GetTransfer(ctx context.Context, req *ReqStatus) (*TransferInfos, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransfer not implemented")
}
func (*UnimplementedDnsManagerServer) OperateTransfer(ctx context.Context, req *TransferInfos) (*RespStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OperateTransfer not implemented")
}
func (*UnimplementedDnsManagerServer) EnableTransfer(ctx context.Context, req *EnableInfos) (*RespStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnableTransfer not implemented")
}
func (*UnimplementedDnsManagerServer) GetSysConf(ctx context.Context, req *ReqStatus) (*SysConfs, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSysConf not implemented")
}
func (*UnimplementedDnsManagerServer) UpdateSysConf(ctx context.Context, req *SysConfs) (*RespStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSysConf not implemented")
}
func (*UnimplementedDnsManagerServer) QueryServiceIP(ctx context.Context, req *ReqStatus) (*RespServiceIP, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryServiceIP not implemented")
}
func (*UnimplementedDnsManagerServer) GetForwardStatus(ctx context.Context, req *ForwardStatusInfos) (*ForwardStatusInfos, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetForwardStatus not implemented")
}

func RegisterDnsManagerServer(s *grpc.Server, srv DnsManagerServer) {
	s.RegisterService(&_DnsManager_serviceDesc, srv)
}

func _DnsManager_GetForward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DnsManagerServer).GetForward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dnsserver.DnsManager/GetForward",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DnsManagerServer).GetForward(ctx, req.(*ReqStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _DnsManager_OperateForward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ForwardInfos)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DnsManagerServer).OperateForward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dnsserver.DnsManager/OperateForward",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DnsManagerServer).OperateForward(ctx, req.(*ForwardInfos))
	}
	return interceptor(ctx, in, info, handler)
}

func _DnsManager_GetDomain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ForwardRefer)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DnsManagerServer).GetDomain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dnsserver.DnsManager/GetDomain",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DnsManagerServer).GetDomain(ctx, req.(*ForwardRefer))
	}
	return interceptor(ctx, in, info, handler)
}

func _DnsManager_OperateDomain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DomainInfos)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DnsManagerServer).OperateDomain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dnsserver.DnsManager/OperateDomain",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DnsManagerServer).OperateDomain(ctx, req.(*DomainInfos))
	}
	return interceptor(ctx, in, info, handler)
}

func _DnsManager_EnableDomain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ForwardEnableMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DnsManagerServer).EnableDomain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dnsserver.DnsManager/EnableDomain",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DnsManagerServer).EnableDomain(ctx, req.(*ForwardEnableMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _DnsManager_GetTransfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DnsManagerServer).GetTransfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dnsserver.DnsManager/GetTransfer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DnsManagerServer).GetTransfer(ctx, req.(*ReqStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _DnsManager_OperateTransfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransferInfos)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DnsManagerServer).OperateTransfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dnsserver.DnsManager/OperateTransfer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DnsManagerServer).OperateTransfer(ctx, req.(*TransferInfos))
	}
	return interceptor(ctx, in, info, handler)
}

func _DnsManager_EnableTransfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableInfos)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DnsManagerServer).EnableTransfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dnsserver.DnsManager/EnableTransfer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DnsManagerServer).EnableTransfer(ctx, req.(*EnableInfos))
	}
	return interceptor(ctx, in, info, handler)
}

func _DnsManager_GetSysConf_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DnsManagerServer).GetSysConf(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dnsserver.DnsManager/GetSysConf",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DnsManagerServer).GetSysConf(ctx, req.(*ReqStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _DnsManager_UpdateSysConf_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SysConfs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DnsManagerServer).UpdateSysConf(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dnsserver.DnsManager/UpdateSysConf",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DnsManagerServer).UpdateSysConf(ctx, req.(*SysConfs))
	}
	return interceptor(ctx, in, info, handler)
}

func _DnsManager_QueryServiceIP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DnsManagerServer).QueryServiceIP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dnsserver.DnsManager/QueryServiceIP",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DnsManagerServer).QueryServiceIP(ctx, req.(*ReqStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _DnsManager_GetForwardStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ForwardStatusInfos)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DnsManagerServer).GetForwardStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dnsserver.DnsManager/GetForwardStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DnsManagerServer).GetForwardStatus(ctx, req.(*ForwardStatusInfos))
	}
	return interceptor(ctx, in, info, handler)
}

var _DnsManager_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dnsserver.DnsManager",
	HandlerType: (*DnsManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetForward",
			Handler:    _DnsManager_GetForward_Handler,
		},
		{
			MethodName: "OperateForward",
			Handler:    _DnsManager_OperateForward_Handler,
		},
		{
			MethodName: "GetDomain",
			Handler:    _DnsManager_GetDomain_Handler,
		},
		{
			MethodName: "OperateDomain",
			Handler:    _DnsManager_OperateDomain_Handler,
		},
		{
			MethodName: "EnableDomain",
			Handler:    _DnsManager_EnableDomain_Handler,
		},
		{
			MethodName: "GetTransfer",
			Handler:    _DnsManager_GetTransfer_Handler,
		},
		{
			MethodName: "OperateTransfer",
			Handler:    _DnsManager_OperateTransfer_Handler,
		},
		{
			MethodName: "EnableTransfer",
			Handler:    _DnsManager_EnableTransfer_Handler,
		},
		{
			MethodName: "GetSysConf",
			Handler:    _DnsManager_GetSysConf_Handler,
		},
		{
			MethodName: "UpdateSysConf",
			Handler:    _DnsManager_UpdateSysConf_Handler,
		},
		{
			MethodName: "QueryServiceIP",
			Handler:    _DnsManager_QueryServiceIP_Handler,
		},
		{
			MethodName: "GetForwardStatus",
			Handler:    _DnsManager_GetForwardStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dnsserver.proto",
}

func (m *ForwardRefer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForwardRefer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForwardRefer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ForwardId != 0 {
		i = encodeVarintDnsserver(dAtA, i, uint64(m.ForwardId))
		i--
		dAtA[i] = 0x10
	}
	if m.DomainId != 0 {
		i = encodeVarintDnsserver(dAtA, i, uint64(m.DomainId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ForwardEnableMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForwardEnableMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForwardEnableMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Enable {
		i--
		if m.Enable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Refer != nil {
		{
			size, err := m.Refer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDnsserver(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReqStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReqStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		dAtA3 := make([]byte, len(m.Id)*10)
		var j2 int
		for _, num := range m.Id {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintDnsserver(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RespStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RespStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RespStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDnsserver(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintDnsserver(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ForwardInfos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForwardInfos) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForwardInfos) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Ev) > 0 {
		for iNdEx := len(m.Ev) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ev[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDnsserver(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.OperateType != 0 {
		i = encodeVarintDnsserver(dAtA, i, uint64(m.OperateType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ForwardInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForwardInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForwardInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Reference) > 0 {
		i -= len(m.Reference)
		copy(dAtA[i:], m.Reference)
		i = encodeVarintDnsserver(dAtA, i, uint64(len(m.Reference)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Domain) > 0 {
		i -= len(m.Domain)
		copy(dAtA[i:], m.Domain)
		i = encodeVarintDnsserver(dAtA, i, uint64(len(m.Domain)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintDnsserver(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DomainInfos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DomainInfos) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DomainInfos) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Ev) > 0 {
		for iNdEx := len(m.Ev) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ev[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDnsserver(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.OperateType != 0 {
		i = encodeVarintDnsserver(dAtA, i, uint64(m.OperateType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DomainInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DomainInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DomainInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Enable {
		i--
		if m.Enable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.Mx != 0 {
		i = encodeVarintDnsserver(dAtA, i, uint64(m.Mx))
		i--
		dAtA[i] = 0x40
	}
	if m.Ttl != 0 {
		i = encodeVarintDnsserver(dAtA, i, uint64(m.Ttl))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintDnsserver(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x32
	}
	if m.IspId != 0 {
		i = encodeVarintDnsserver(dAtA, i, uint64(m.IspId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintDnsserver(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDnsserver(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ForId != 0 {
		i = encodeVarintDnsserver(dAtA, i, uint64(m.ForId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintDnsserver(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EnableInfos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnableInfos) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EnableInfos) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Enable {
		i--
		if m.Enable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintDnsserver(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RecursionInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecursionInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecursionInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.JumpAddr) > 0 {
		i -= len(m.JumpAddr)
		copy(dAtA[i:], m.JumpAddr)
		i = encodeVarintDnsserver(dAtA, i, uint64(len(m.JumpAddr)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Dns64Prefix) > 0 {
		i -= len(m.Dns64Prefix)
		copy(dAtA[i:], m.Dns64Prefix)
		i = encodeVarintDnsserver(dAtA, i, uint64(len(m.Dns64Prefix)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Dns64Synthall {
		i--
		if m.Dns64Synthall {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Dns64Enable {
		i--
		if m.Dns64Enable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Dns46Enable {
		i--
		if m.Dns46Enable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.RecursionEnable {
		i--
		if m.RecursionEnable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TransferInfos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferInfos) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransferInfos) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Ev) > 0 {
		for iNdEx := len(m.Ev) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ev[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDnsserver(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.OperateType != 0 {
		i = encodeVarintDnsserver(dAtA, i, uint64(m.OperateType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TransferInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransferInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Reference) > 0 {
		i -= len(m.Reference)
		copy(dAtA[i:], m.Reference)
		i = encodeVarintDnsserver(dAtA, i, uint64(len(m.Reference)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Enable {
		i--
		if m.Enable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Ip) > 0 {
		i -= len(m.Ip)
		copy(dAtA[i:], m.Ip)
		i = encodeVarintDnsserver(dAtA, i, uint64(len(m.Ip)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Domain) > 0 {
		i -= len(m.Domain)
		copy(dAtA[i:], m.Domain)
		i = encodeVarintDnsserver(dAtA, i, uint64(len(m.Domain)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintDnsserver(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SysConfs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SysConfs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SysConfs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Ip) > 0 {
		for iNdEx := len(m.Ip) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ip[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDnsserver(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDnsserver(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Sys != nil {
		{
			size, err := m.Sys.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDnsserver(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SysConf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SysConf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SysConf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TcpEnable {
		i--
		if m.TcpEnable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.CnamePriority {
		i--
		if m.CnamePriority {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Port != 0 {
		i = encodeVarintDnsserver(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ServiceIPInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceIPInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceIPInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Ip) > 0 {
		i -= len(m.Ip)
		copy(dAtA[i:], m.Ip)
		i = encodeVarintDnsserver(dAtA, i, uint64(len(m.Ip)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ForwardStatusInfos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForwardStatusInfos) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForwardStatusInfos) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Ev) > 0 {
		for iNdEx := len(m.Ev) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ev[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDnsserver(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ForStatusInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForStatusInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForStatusInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != 0 {
		i = encodeVarintDnsserver(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.Refer != nil {
		{
			size, err := m.Refer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDnsserver(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RespServiceIP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RespServiceIP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RespServiceIP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Ip) > 0 {
		for iNdEx := len(m.Ip) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ip[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDnsserver(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintDnsserver(dAtA []byte, offset int, v uint64) int {
	offset -= sovDnsserver(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ForwardRefer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DomainId != 0 {
		n += 1 + sovDnsserver(uint64(m.DomainId))
	}
	if m.ForwardId != 0 {
		n += 1 + sovDnsserver(uint64(m.ForwardId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ForwardEnableMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Refer != nil {
		l = m.Refer.Size()
		n += 1 + l + sovDnsserver(uint64(l))
	}
	if m.Enable {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReqStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Id) > 0 {
		l = 0
		for _, e := range m.Id {
			l += sovDnsserver(uint64(e))
		}
		n += 1 + sovDnsserver(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RespStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovDnsserver(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDnsserver(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ForwardInfos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OperateType != 0 {
		n += 1 + sovDnsserver(uint64(m.OperateType))
	}
	if len(m.Ev) > 0 {
		for _, e := range m.Ev {
			l = e.Size()
			n += 1 + l + sovDnsserver(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ForwardInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovDnsserver(uint64(m.Id))
	}
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovDnsserver(uint64(l))
	}
	l = len(m.Reference)
	if l > 0 {
		n += 1 + l + sovDnsserver(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DomainInfos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OperateType != 0 {
		n += 1 + sovDnsserver(uint64(m.OperateType))
	}
	if len(m.Ev) > 0 {
		for _, e := range m.Ev {
			l = e.Size()
			n += 1 + l + sovDnsserver(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DomainInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovDnsserver(uint64(m.Id))
	}
	if m.ForId != 0 {
		n += 1 + sovDnsserver(uint64(m.ForId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDnsserver(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovDnsserver(uint64(l))
	}
	if m.IspId != 0 {
		n += 1 + sovDnsserver(uint64(m.IspId))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovDnsserver(uint64(l))
	}
	if m.Ttl != 0 {
		n += 1 + sovDnsserver(uint64(m.Ttl))
	}
	if m.Mx != 0 {
		n += 1 + sovDnsserver(uint64(m.Mx))
	}
	if m.Enable {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EnableInfos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovDnsserver(uint64(m.Id))
	}
	if m.Enable {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RecursionInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RecursionEnable {
		n += 2
	}
	if m.Dns46Enable {
		n += 2
	}
	if m.Dns64Enable {
		n += 2
	}
	if m.Dns64Synthall {
		n += 2
	}
	l = len(m.Dns64Prefix)
	if l > 0 {
		n += 1 + l + sovDnsserver(uint64(l))
	}
	l = len(m.JumpAddr)
	if l > 0 {
		n += 1 + l + sovDnsserver(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransferInfos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OperateType != 0 {
		n += 1 + sovDnsserver(uint64(m.OperateType))
	}
	if len(m.Ev) > 0 {
		for _, e := range m.Ev {
			l = e.Size()
			n += 1 + l + sovDnsserver(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransferInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovDnsserver(uint64(m.Id))
	}
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovDnsserver(uint64(l))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovDnsserver(uint64(l))
	}
	if m.Enable {
		n += 2
	}
	l = len(m.Reference)
	if l > 0 {
		n += 1 + l + sovDnsserver(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SysConfs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sys != nil {
		l = m.Sys.Size()
		n += 1 + l + sovDnsserver(uint64(l))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovDnsserver(uint64(l))
	}
	if len(m.Ip) > 0 {
		for _, e := range m.Ip {
			l = e.Size()
			n += 1 + l + sovDnsserver(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SysConf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Port != 0 {
		n += 1 + sovDnsserver(uint64(m.Port))
	}
	if m.CnamePriority {
		n += 2
	}
	if m.TcpEnable {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServiceIPInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovDnsserver(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ForwardStatusInfos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ev) > 0 {
		for _, e := range m.Ev {
			l = e.Size()
			n += 1 + l + sovDnsserver(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ForStatusInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Refer != nil {
		l = m.Refer.Size()
		n += 1 + l + sovDnsserver(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovDnsserver(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RespServiceIP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ip) > 0 {
		for _, e := range m.Ip {
			l = e.Size()
			n += 1 + l + sovDnsserver(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovDnsserver(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDnsserver(x uint64) (n int) {
	return sovDnsserver(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ForwardRefer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDnsserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForwardRefer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForwardRefer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainId", wireType)
			}
			m.DomainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DomainId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardId", wireType)
			}
			m.ForwardId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForwardId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDnsserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDnsserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDnsserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForwardEnableMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDnsserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForwardEnableMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForwardEnableMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDnsserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDnsserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Refer == nil {
				m.Refer = &ForwardRefer{}
			}
			if err := m.Refer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDnsserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDnsserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDnsserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDnsserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDnsserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Id = append(m.Id, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDnsserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDnsserver
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthDnsserver
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Id) == 0 {
					m.Id = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDnsserver
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Id = append(m.Id, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDnsserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDnsserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDnsserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RespStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDnsserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RespStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RespStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDnsserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDnsserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDnsserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDnsserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDnsserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForwardInfos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDnsserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForwardInfos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForwardInfos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperateType", wireType)
			}
			m.OperateType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperateType |= OperType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ev", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDnsserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDnsserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ev = append(m.Ev, &ForwardInfo{})
			if err := m.Ev[len(m.Ev)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDnsserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDnsserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDnsserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForwardInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDnsserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForwardInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForwardInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDnsserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDnsserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reference", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDnsserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDnsserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reference = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDnsserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDnsserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDnsserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DomainInfos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDnsserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DomainInfos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DomainInfos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperateType", wireType)
			}
			m.OperateType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperateType |= OperType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ev", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDnsserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDnsserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ev = append(m.Ev, &DomainInfo{})
			if err := m.Ev[len(m.Ev)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDnsserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDnsserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDnsserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DomainInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDnsserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DomainInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DomainInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForId", wireType)
			}
			m.ForId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDnsserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDnsserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDnsserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDnsserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IspId", wireType)
			}
			m.IspId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IspId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDnsserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDnsserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			m.Ttl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ttl |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mx", wireType)
			}
			m.Mx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDnsserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDnsserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDnsserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnableInfos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDnsserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnableInfos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnableInfos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDnsserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDnsserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDnsserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecursionInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDnsserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecursionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecursionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecursionEnable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RecursionEnable = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dns46Enable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dns46Enable = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dns64Enable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dns64Enable = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dns64Synthall", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dns64Synthall = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dns64Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDnsserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDnsserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dns64Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JumpAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDnsserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDnsserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JumpAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDnsserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDnsserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDnsserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferInfos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDnsserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferInfos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferInfos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperateType", wireType)
			}
			m.OperateType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperateType |= OperType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ev", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDnsserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDnsserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ev = append(m.Ev, &TransferInfo{})
			if err := m.Ev[len(m.Ev)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDnsserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDnsserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDnsserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDnsserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDnsserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDnsserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDnsserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDnsserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enable = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reference", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDnsserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDnsserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reference = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDnsserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDnsserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDnsserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SysConfs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDnsserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SysConfs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SysConfs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDnsserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDnsserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sys == nil {
				m.Sys = &SysConf{}
			}
			if err := m.Sys.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDnsserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDnsserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &RecursionInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDnsserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDnsserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = append(m.Ip, &ServiceIPInfo{})
			if err := m.Ip[len(m.Ip)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDnsserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDnsserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDnsserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SysConf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDnsserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SysConf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SysConf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CnamePriority", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CnamePriority = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpEnable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TcpEnable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDnsserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDnsserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDnsserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceIPInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDnsserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceIPInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceIPInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDnsserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDnsserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDnsserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDnsserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDnsserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForwardStatusInfos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDnsserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForwardStatusInfos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForwardStatusInfos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ev", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDnsserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDnsserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ev = append(m.Ev, &ForStatusInfo{})
			if err := m.Ev[len(m.Ev)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDnsserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDnsserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDnsserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForStatusInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDnsserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForStatusInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForStatusInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDnsserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDnsserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Refer == nil {
				m.Refer = &ForwardRefer{}
			}
			if err := m.Refer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDnsserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDnsserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDnsserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RespServiceIP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDnsserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RespServiceIP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RespServiceIP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDnsserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDnsserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = append(m.Ip, &ServiceIPInfo{})
			if err := m.Ip[len(m.Ip)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDnsserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDnsserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDnsserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDnsserver(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDnsserver
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDnsserver
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDnsserver
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDnsserver
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDnsserver
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDnsserver        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDnsserver          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDnsserver = fmt.Errorf("proto: unexpected end of group")
)
